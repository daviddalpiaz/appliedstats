<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Applied Statistics with R</title>
  <meta name="description" content="Applied Statistics with <code>R</code>">
  <meta name="generator" content="bookdown 0.7.14 and GitBook 2.6.7">

  <meta property="og:title" content="Applied Statistics with R" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="https://daviddalpiaz.github.io/appliedstats/" />
  
  
  <meta name="github-repo" content="daviddalpiaz/appliedstats" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Applied Statistics with R" />
  
  
  



<meta name="date" content="2018-07-14">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  <link rel="shortcut icon" href="favicon.gif" type="image/x-icon">
<link rel="prev" href="variable-selection-and-model-building.html">
<link rel="next" href="beyond.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Applied Statistics with `R`</a></li>

<li class="divider"></li>
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> Introduction</a><ul>
<li class="chapter" data-level="1.1" data-path="index.html"><a href="index.html#about-this-book"><i class="fa fa-check"></i><b>1.1</b> About This Book</a></li>
<li class="chapter" data-level="1.2" data-path="index.html"><a href="index.html#conventions"><i class="fa fa-check"></i><b>1.2</b> Conventions</a></li>
<li class="chapter" data-level="1.3" data-path="index.html"><a href="index.html#acknowledgements"><i class="fa fa-check"></i><b>1.3</b> Acknowledgements</a></li>
<li class="chapter" data-level="1.4" data-path="index.html"><a href="index.html#license"><i class="fa fa-check"></i><b>1.4</b> License</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="introduction-to-r.html"><a href="introduction-to-r.html"><i class="fa fa-check"></i><b>2</b> Introduction to <code>R</code></a><ul>
<li class="chapter" data-level="2.1" data-path="introduction-to-r.html"><a href="introduction-to-r.html#getting-started"><i class="fa fa-check"></i><b>2.1</b> Getting Started</a></li>
<li class="chapter" data-level="2.2" data-path="introduction-to-r.html"><a href="introduction-to-r.html#basic-calculations"><i class="fa fa-check"></i><b>2.2</b> Basic Calculations</a></li>
<li class="chapter" data-level="2.3" data-path="introduction-to-r.html"><a href="introduction-to-r.html#getting-help"><i class="fa fa-check"></i><b>2.3</b> Getting Help</a></li>
<li class="chapter" data-level="2.4" data-path="introduction-to-r.html"><a href="introduction-to-r.html#installing-packages"><i class="fa fa-check"></i><b>2.4</b> Installing Packages</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="data-and-programming.html"><a href="data-and-programming.html"><i class="fa fa-check"></i><b>3</b> Data and Programming</a><ul>
<li class="chapter" data-level="3.1" data-path="data-and-programming.html"><a href="data-and-programming.html#data-types"><i class="fa fa-check"></i><b>3.1</b> Data Types</a></li>
<li class="chapter" data-level="3.2" data-path="data-and-programming.html"><a href="data-and-programming.html#data-structures"><i class="fa fa-check"></i><b>3.2</b> Data Structures</a><ul>
<li class="chapter" data-level="3.2.1" data-path="data-and-programming.html"><a href="data-and-programming.html#vectors"><i class="fa fa-check"></i><b>3.2.1</b> Vectors</a></li>
<li class="chapter" data-level="3.2.2" data-path="data-and-programming.html"><a href="data-and-programming.html#vectorization"><i class="fa fa-check"></i><b>3.2.2</b> Vectorization</a></li>
<li class="chapter" data-level="3.2.3" data-path="data-and-programming.html"><a href="data-and-programming.html#logical-operators"><i class="fa fa-check"></i><b>3.2.3</b> Logical Operators</a></li>
<li class="chapter" data-level="3.2.4" data-path="data-and-programming.html"><a href="data-and-programming.html#more-vectorization"><i class="fa fa-check"></i><b>3.2.4</b> More Vectorization</a></li>
<li class="chapter" data-level="3.2.5" data-path="data-and-programming.html"><a href="data-and-programming.html#matrices"><i class="fa fa-check"></i><b>3.2.5</b> Matrices</a></li>
<li class="chapter" data-level="3.2.6" data-path="data-and-programming.html"><a href="data-and-programming.html#lists"><i class="fa fa-check"></i><b>3.2.6</b> Lists</a></li>
<li class="chapter" data-level="3.2.7" data-path="data-and-programming.html"><a href="data-and-programming.html#data-frames"><i class="fa fa-check"></i><b>3.2.7</b> Data Frames</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="data-and-programming.html"><a href="data-and-programming.html#programming-basics"><i class="fa fa-check"></i><b>3.3</b> Programming Basics</a><ul>
<li class="chapter" data-level="3.3.1" data-path="data-and-programming.html"><a href="data-and-programming.html#control-flow"><i class="fa fa-check"></i><b>3.3.1</b> Control Flow</a></li>
<li class="chapter" data-level="3.3.2" data-path="data-and-programming.html"><a href="data-and-programming.html#functions"><i class="fa fa-check"></i><b>3.3.2</b> Functions</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="summarizing-data.html"><a href="summarizing-data.html"><i class="fa fa-check"></i><b>4</b> Summarizing Data</a><ul>
<li class="chapter" data-level="4.1" data-path="summarizing-data.html"><a href="summarizing-data.html#summary-statistics"><i class="fa fa-check"></i><b>4.1</b> Summary Statistics</a><ul>
<li class="chapter" data-level="" data-path="summarizing-data.html"><a href="summarizing-data.html#central-tendency"><i class="fa fa-check"></i>Central Tendency</a></li>
<li class="chapter" data-level="" data-path="summarizing-data.html"><a href="summarizing-data.html#spread"><i class="fa fa-check"></i>Spread</a></li>
<li class="chapter" data-level="" data-path="summarizing-data.html"><a href="summarizing-data.html#categorical"><i class="fa fa-check"></i>Categorical</a></li>
</ul></li>
<li class="chapter" data-level="4.2" data-path="summarizing-data.html"><a href="summarizing-data.html#plotting"><i class="fa fa-check"></i><b>4.2</b> Plotting</a><ul>
<li class="chapter" data-level="4.2.1" data-path="summarizing-data.html"><a href="summarizing-data.html#histograms"><i class="fa fa-check"></i><b>4.2.1</b> Histograms</a></li>
<li class="chapter" data-level="4.2.2" data-path="summarizing-data.html"><a href="summarizing-data.html#barplots"><i class="fa fa-check"></i><b>4.2.2</b> Barplots</a></li>
<li class="chapter" data-level="4.2.3" data-path="summarizing-data.html"><a href="summarizing-data.html#boxplots"><i class="fa fa-check"></i><b>4.2.3</b> Boxplots</a></li>
<li class="chapter" data-level="4.2.4" data-path="summarizing-data.html"><a href="summarizing-data.html#scatterplots"><i class="fa fa-check"></i><b>4.2.4</b> Scatterplots</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5" data-path="probability-and-statistics-in-r.html"><a href="probability-and-statistics-in-r.html"><i class="fa fa-check"></i><b>5</b> Probability and Statistics in <code>R</code></a><ul>
<li class="chapter" data-level="5.1" data-path="probability-and-statistics-in-r.html"><a href="probability-and-statistics-in-r.html#probability-in-r"><i class="fa fa-check"></i><b>5.1</b> Probability in <code>R</code></a><ul>
<li class="chapter" data-level="5.1.1" data-path="probability-and-statistics-in-r.html"><a href="probability-and-statistics-in-r.html#distributions"><i class="fa fa-check"></i><b>5.1.1</b> Distributions</a></li>
</ul></li>
<li class="chapter" data-level="5.2" data-path="probability-and-statistics-in-r.html"><a href="probability-and-statistics-in-r.html#hypothesis-tests-in-r"><i class="fa fa-check"></i><b>5.2</b> Hypothesis Tests in <code>R</code></a><ul>
<li class="chapter" data-level="5.2.1" data-path="probability-and-statistics-in-r.html"><a href="probability-and-statistics-in-r.html#one-sample-t-test-review"><i class="fa fa-check"></i><b>5.2.1</b> One Sample t-Test: Review</a></li>
<li class="chapter" data-level="5.2.2" data-path="probability-and-statistics-in-r.html"><a href="probability-and-statistics-in-r.html#one-sample-t-test-example"><i class="fa fa-check"></i><b>5.2.2</b> One Sample t-Test: Example</a></li>
<li class="chapter" data-level="5.2.3" data-path="probability-and-statistics-in-r.html"><a href="probability-and-statistics-in-r.html#two-sample-t-test-review"><i class="fa fa-check"></i><b>5.2.3</b> Two Sample t-Test: Review</a></li>
<li class="chapter" data-level="5.2.4" data-path="probability-and-statistics-in-r.html"><a href="probability-and-statistics-in-r.html#two-sample-t-test-example"><i class="fa fa-check"></i><b>5.2.4</b> Two Sample t-Test: Example</a></li>
</ul></li>
<li class="chapter" data-level="5.3" data-path="probability-and-statistics-in-r.html"><a href="probability-and-statistics-in-r.html#simulation"><i class="fa fa-check"></i><b>5.3</b> Simulation</a><ul>
<li class="chapter" data-level="5.3.1" data-path="probability-and-statistics-in-r.html"><a href="probability-and-statistics-in-r.html#paired-differences"><i class="fa fa-check"></i><b>5.3.1</b> Paired Differences</a></li>
<li class="chapter" data-level="5.3.2" data-path="probability-and-statistics-in-r.html"><a href="probability-and-statistics-in-r.html#distribution-of-a-sample-mean"><i class="fa fa-check"></i><b>5.3.2</b> Distribution of a Sample Mean</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="6" data-path="r-resources.html"><a href="r-resources.html"><i class="fa fa-check"></i><b>6</b> <code>R</code> Resources</a><ul>
<li class="chapter" data-level="6.1" data-path="r-resources.html"><a href="r-resources.html#beginner-tutorials-and-references"><i class="fa fa-check"></i><b>6.1</b> Beginner Tutorials and References</a></li>
<li class="chapter" data-level="6.2" data-path="r-resources.html"><a href="r-resources.html#intermediate-references"><i class="fa fa-check"></i><b>6.2</b> Intermediate References</a></li>
<li class="chapter" data-level="6.3" data-path="r-resources.html"><a href="r-resources.html#advanced-references"><i class="fa fa-check"></i><b>6.3</b> Advanced References</a></li>
<li class="chapter" data-level="6.4" data-path="r-resources.html"><a href="r-resources.html#quick-comparisons-to-other-languages"><i class="fa fa-check"></i><b>6.4</b> Quick Comparisons to Other Languages</a></li>
<li class="chapter" data-level="6.5" data-path="r-resources.html"><a href="r-resources.html#rstudio-and-rmarkdown-videos"><i class="fa fa-check"></i><b>6.5</b> RStudio and RMarkdown Videos</a></li>
<li class="chapter" data-level="6.6" data-path="r-resources.html"><a href="r-resources.html#rmarkdown-template"><i class="fa fa-check"></i><b>6.6</b> RMarkdown Template</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="simple-linear-regression.html"><a href="simple-linear-regression.html"><i class="fa fa-check"></i><b>7</b> Simple Linear Regression</a><ul>
<li class="chapter" data-level="7.1" data-path="simple-linear-regression.html"><a href="simple-linear-regression.html#modeling"><i class="fa fa-check"></i><b>7.1</b> Modeling</a><ul>
<li class="chapter" data-level="7.1.1" data-path="simple-linear-regression.html"><a href="simple-linear-regression.html#simple-linear-regression-model"><i class="fa fa-check"></i><b>7.1.1</b> Simple Linear Regression Model</a></li>
</ul></li>
<li class="chapter" data-level="7.2" data-path="simple-linear-regression.html"><a href="simple-linear-regression.html#least-squares-approach"><i class="fa fa-check"></i><b>7.2</b> Least Squares Approach</a><ul>
<li class="chapter" data-level="7.2.1" data-path="simple-linear-regression.html"><a href="simple-linear-regression.html#making-predictions"><i class="fa fa-check"></i><b>7.2.1</b> Making Predictions</a></li>
<li class="chapter" data-level="7.2.2" data-path="simple-linear-regression.html"><a href="simple-linear-regression.html#residuals"><i class="fa fa-check"></i><b>7.2.2</b> Residuals</a></li>
<li class="chapter" data-level="7.2.3" data-path="simple-linear-regression.html"><a href="simple-linear-regression.html#variance-estimation"><i class="fa fa-check"></i><b>7.2.3</b> Variance Estimation</a></li>
</ul></li>
<li class="chapter" data-level="7.3" data-path="simple-linear-regression.html"><a href="simple-linear-regression.html#decomposition-of-variation"><i class="fa fa-check"></i><b>7.3</b> Decomposition of Variation</a><ul>
<li class="chapter" data-level="7.3.1" data-path="simple-linear-regression.html"><a href="simple-linear-regression.html#coefficient-of-determination"><i class="fa fa-check"></i><b>7.3.1</b> Coefficient of Determination</a></li>
</ul></li>
<li class="chapter" data-level="7.4" data-path="simple-linear-regression.html"><a href="simple-linear-regression.html#the-lm-function"><i class="fa fa-check"></i><b>7.4</b> The <code>lm</code> Function</a></li>
<li class="chapter" data-level="7.5" data-path="simple-linear-regression.html"><a href="simple-linear-regression.html#maximum-likelihood-estimation-mle-approach"><i class="fa fa-check"></i><b>7.5</b> Maximum Likelihood Estimation (MLE) Approach</a></li>
<li class="chapter" data-level="7.6" data-path="simple-linear-regression.html"><a href="simple-linear-regression.html#simulating-slr"><i class="fa fa-check"></i><b>7.6</b> Simulating SLR</a></li>
<li class="chapter" data-level="7.7" data-path="simple-linear-regression.html"><a href="simple-linear-regression.html#history"><i class="fa fa-check"></i><b>7.7</b> History</a></li>
<li class="chapter" data-level="7.8" data-path="simple-linear-regression.html"><a href="simple-linear-regression.html#r-markdown"><i class="fa fa-check"></i><b>7.8</b> <code>R</code> Markdown</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="inference-for-simple-linear-regression.html"><a href="inference-for-simple-linear-regression.html"><i class="fa fa-check"></i><b>8</b> Inference for Simple Linear Regression</a><ul>
<li class="chapter" data-level="8.1" data-path="inference-for-simple-linear-regression.html"><a href="inference-for-simple-linear-regression.html#gaussmarkov-theorem"><i class="fa fa-check"></i><b>8.1</b> Gauss–Markov Theorem</a></li>
<li class="chapter" data-level="8.2" data-path="inference-for-simple-linear-regression.html"><a href="inference-for-simple-linear-regression.html#sampling-distributions"><i class="fa fa-check"></i><b>8.2</b> Sampling Distributions</a><ul>
<li class="chapter" data-level="8.2.1" data-path="inference-for-simple-linear-regression.html"><a href="inference-for-simple-linear-regression.html#simulating-sampling-distributions"><i class="fa fa-check"></i><b>8.2.1</b> Simulating Sampling Distributions</a></li>
</ul></li>
<li class="chapter" data-level="8.3" data-path="inference-for-simple-linear-regression.html"><a href="inference-for-simple-linear-regression.html#standard-errors"><i class="fa fa-check"></i><b>8.3</b> Standard Errors</a></li>
<li class="chapter" data-level="8.4" data-path="inference-for-simple-linear-regression.html"><a href="inference-for-simple-linear-regression.html#confidence-intervals-for-slope-and-intercept"><i class="fa fa-check"></i><b>8.4</b> Confidence Intervals for Slope and Intercept</a></li>
<li class="chapter" data-level="8.5" data-path="inference-for-simple-linear-regression.html"><a href="inference-for-simple-linear-regression.html#hypothesis-tests"><i class="fa fa-check"></i><b>8.5</b> Hypothesis Tests</a></li>
<li class="chapter" data-level="8.6" data-path="inference-for-simple-linear-regression.html"><a href="inference-for-simple-linear-regression.html#cars-example"><i class="fa fa-check"></i><b>8.6</b> <code>cars</code> Example</a><ul>
<li class="chapter" data-level="8.6.1" data-path="inference-for-simple-linear-regression.html"><a href="inference-for-simple-linear-regression.html#tests-in-r"><i class="fa fa-check"></i><b>8.6.1</b> Tests in <code>R</code></a></li>
<li class="chapter" data-level="8.6.2" data-path="inference-for-simple-linear-regression.html"><a href="inference-for-simple-linear-regression.html#significance-of-regression-t-test"><i class="fa fa-check"></i><b>8.6.2</b> Significance of Regression, t-Test</a></li>
<li class="chapter" data-level="8.6.3" data-path="inference-for-simple-linear-regression.html"><a href="inference-for-simple-linear-regression.html#confidence-intervals-in-r"><i class="fa fa-check"></i><b>8.6.3</b> Confidence Intervals in <code>R</code></a></li>
</ul></li>
<li class="chapter" data-level="8.7" data-path="inference-for-simple-linear-regression.html"><a href="inference-for-simple-linear-regression.html#confidence-interval-for-mean-response"><i class="fa fa-check"></i><b>8.7</b> Confidence Interval for Mean Response</a></li>
<li class="chapter" data-level="8.8" data-path="inference-for-simple-linear-regression.html"><a href="inference-for-simple-linear-regression.html#prediction-interval-for-new-observations"><i class="fa fa-check"></i><b>8.8</b> Prediction Interval for New Observations</a></li>
<li class="chapter" data-level="8.9" data-path="inference-for-simple-linear-regression.html"><a href="inference-for-simple-linear-regression.html#confidence-and-prediction-bands"><i class="fa fa-check"></i><b>8.9</b> Confidence and Prediction Bands</a></li>
<li class="chapter" data-level="8.10" data-path="inference-for-simple-linear-regression.html"><a href="inference-for-simple-linear-regression.html#significance-of-regression-f-test"><i class="fa fa-check"></i><b>8.10</b> Significance of Regression, F-Test</a></li>
<li class="chapter" data-level="8.11" data-path="inference-for-simple-linear-regression.html"><a href="inference-for-simple-linear-regression.html#r-markdown-1"><i class="fa fa-check"></i><b>8.11</b> <code>R</code> Markdown</a></li>
</ul></li>
<li class="chapter" data-level="9" data-path="multiple-linear-regression.html"><a href="multiple-linear-regression.html"><i class="fa fa-check"></i><b>9</b> Multiple Linear Regression</a><ul>
<li class="chapter" data-level="9.1" data-path="multiple-linear-regression.html"><a href="multiple-linear-regression.html#matrix-approach-to-regression"><i class="fa fa-check"></i><b>9.1</b> Matrix Approach to Regression</a></li>
<li class="chapter" data-level="9.2" data-path="multiple-linear-regression.html"><a href="multiple-linear-regression.html#sampling-distribution"><i class="fa fa-check"></i><b>9.2</b> Sampling Distribution</a><ul>
<li class="chapter" data-level="9.2.1" data-path="multiple-linear-regression.html"><a href="multiple-linear-regression.html#single-parameter-tests"><i class="fa fa-check"></i><b>9.2.1</b> Single Parameter Tests</a></li>
<li class="chapter" data-level="9.2.2" data-path="multiple-linear-regression.html"><a href="multiple-linear-regression.html#confidence-intervals"><i class="fa fa-check"></i><b>9.2.2</b> Confidence Intervals</a></li>
<li class="chapter" data-level="9.2.3" data-path="multiple-linear-regression.html"><a href="multiple-linear-regression.html#confidence-intervals-for-mean-response"><i class="fa fa-check"></i><b>9.2.3</b> Confidence Intervals for Mean Response</a></li>
<li class="chapter" data-level="9.2.4" data-path="multiple-linear-regression.html"><a href="multiple-linear-regression.html#prediction-intervals"><i class="fa fa-check"></i><b>9.2.4</b> Prediction Intervals</a></li>
</ul></li>
<li class="chapter" data-level="9.3" data-path="multiple-linear-regression.html"><a href="multiple-linear-regression.html#significance-of-regression"><i class="fa fa-check"></i><b>9.3</b> Significance of Regression</a></li>
<li class="chapter" data-level="9.4" data-path="multiple-linear-regression.html"><a href="multiple-linear-regression.html#nested-models"><i class="fa fa-check"></i><b>9.4</b> Nested Models</a></li>
<li class="chapter" data-level="9.5" data-path="multiple-linear-regression.html"><a href="multiple-linear-regression.html#simulation-1"><i class="fa fa-check"></i><b>9.5</b> Simulation</a></li>
<li class="chapter" data-level="9.6" data-path="multiple-linear-regression.html"><a href="multiple-linear-regression.html#r-markdown-2"><i class="fa fa-check"></i><b>9.6</b> <code>R</code> Markdown</a></li>
</ul></li>
<li class="chapter" data-level="10" data-path="model-building.html"><a href="model-building.html"><i class="fa fa-check"></i><b>10</b> Model Building</a><ul>
<li class="chapter" data-level="10.1" data-path="model-building.html"><a href="model-building.html#family-form-and-fit"><i class="fa fa-check"></i><b>10.1</b> Family, Form, and Fit</a><ul>
<li class="chapter" data-level="10.1.1" data-path="model-building.html"><a href="model-building.html#fit"><i class="fa fa-check"></i><b>10.1.1</b> Fit</a></li>
<li class="chapter" data-level="10.1.2" data-path="model-building.html"><a href="model-building.html#form"><i class="fa fa-check"></i><b>10.1.2</b> Form</a></li>
<li class="chapter" data-level="10.1.3" data-path="model-building.html"><a href="model-building.html#family"><i class="fa fa-check"></i><b>10.1.3</b> Family</a></li>
<li class="chapter" data-level="10.1.4" data-path="model-building.html"><a href="model-building.html#assumed-model-fitted-model"><i class="fa fa-check"></i><b>10.1.4</b> Assumed Model, Fitted Model</a></li>
</ul></li>
<li class="chapter" data-level="10.2" data-path="model-building.html"><a href="model-building.html#explanation-versus-prediction"><i class="fa fa-check"></i><b>10.2</b> Explanation versus Prediction</a><ul>
<li class="chapter" data-level="10.2.1" data-path="model-building.html"><a href="model-building.html#explanation"><i class="fa fa-check"></i><b>10.2.1</b> Explanation</a></li>
<li class="chapter" data-level="10.2.2" data-path="model-building.html"><a href="model-building.html#prediction"><i class="fa fa-check"></i><b>10.2.2</b> Prediction</a></li>
</ul></li>
<li class="chapter" data-level="10.3" data-path="model-building.html"><a href="model-building.html#summary"><i class="fa fa-check"></i><b>10.3</b> Summary</a></li>
<li class="chapter" data-level="10.4" data-path="model-building.html"><a href="model-building.html#r-markdown-3"><i class="fa fa-check"></i><b>10.4</b> <code>R</code> Markdown</a></li>
</ul></li>
<li class="chapter" data-level="11" data-path="categorical-predictors-and-interactions.html"><a href="categorical-predictors-and-interactions.html"><i class="fa fa-check"></i><b>11</b> Categorical Predictors and Interactions</a><ul>
<li class="chapter" data-level="11.1" data-path="categorical-predictors-and-interactions.html"><a href="categorical-predictors-and-interactions.html#dummy-variables"><i class="fa fa-check"></i><b>11.1</b> Dummy Variables</a></li>
<li class="chapter" data-level="11.2" data-path="categorical-predictors-and-interactions.html"><a href="categorical-predictors-and-interactions.html#interactions"><i class="fa fa-check"></i><b>11.2</b> Interactions</a></li>
<li class="chapter" data-level="11.3" data-path="categorical-predictors-and-interactions.html"><a href="categorical-predictors-and-interactions.html#factor-variables"><i class="fa fa-check"></i><b>11.3</b> Factor Variables</a><ul>
<li class="chapter" data-level="11.3.1" data-path="categorical-predictors-and-interactions.html"><a href="categorical-predictors-and-interactions.html#factors-with-more-than-two-levels"><i class="fa fa-check"></i><b>11.3.1</b> Factors with More Than Two Levels</a></li>
</ul></li>
<li class="chapter" data-level="11.4" data-path="categorical-predictors-and-interactions.html"><a href="categorical-predictors-and-interactions.html#parameterization"><i class="fa fa-check"></i><b>11.4</b> Parameterization</a></li>
<li class="chapter" data-level="11.5" data-path="categorical-predictors-and-interactions.html"><a href="categorical-predictors-and-interactions.html#building-larger-models"><i class="fa fa-check"></i><b>11.5</b> Building Larger Models</a></li>
<li class="chapter" data-level="11.6" data-path="categorical-predictors-and-interactions.html"><a href="categorical-predictors-and-interactions.html#r-markdown-4"><i class="fa fa-check"></i><b>11.6</b> <code>R</code> Markdown</a></li>
</ul></li>
<li class="chapter" data-level="12" data-path="analysis-of-variance.html"><a href="analysis-of-variance.html"><i class="fa fa-check"></i><b>12</b> Analysis of Variance</a><ul>
<li class="chapter" data-level="12.1" data-path="analysis-of-variance.html"><a href="analysis-of-variance.html#experiments"><i class="fa fa-check"></i><b>12.1</b> Experiments</a></li>
<li class="chapter" data-level="12.2" data-path="analysis-of-variance.html"><a href="analysis-of-variance.html#two-sample-t-test"><i class="fa fa-check"></i><b>12.2</b> Two-Sample t-Test</a></li>
<li class="chapter" data-level="12.3" data-path="analysis-of-variance.html"><a href="analysis-of-variance.html#one-way-anova"><i class="fa fa-check"></i><b>12.3</b> One-Way ANOVA</a><ul>
<li class="chapter" data-level="12.3.1" data-path="analysis-of-variance.html"><a href="analysis-of-variance.html#factor-variables-1"><i class="fa fa-check"></i><b>12.3.1</b> Factor Variables</a></li>
<li class="chapter" data-level="12.3.2" data-path="analysis-of-variance.html"><a href="analysis-of-variance.html#some-simulation"><i class="fa fa-check"></i><b>12.3.2</b> Some Simulation</a></li>
<li class="chapter" data-level="12.3.3" data-path="analysis-of-variance.html"><a href="analysis-of-variance.html#power"><i class="fa fa-check"></i><b>12.3.3</b> Power</a></li>
</ul></li>
<li class="chapter" data-level="12.4" data-path="analysis-of-variance.html"><a href="analysis-of-variance.html#post-hoc-testing"><i class="fa fa-check"></i><b>12.4</b> Post Hoc Testing</a></li>
<li class="chapter" data-level="12.5" data-path="analysis-of-variance.html"><a href="analysis-of-variance.html#two-way-anova"><i class="fa fa-check"></i><b>12.5</b> Two-Way ANOVA</a></li>
<li class="chapter" data-level="12.6" data-path="analysis-of-variance.html"><a href="analysis-of-variance.html#r-markdown-5"><i class="fa fa-check"></i><b>12.6</b> <code>R</code> Markdown</a></li>
</ul></li>
<li class="chapter" data-level="13" data-path="model-diagnostics.html"><a href="model-diagnostics.html"><i class="fa fa-check"></i><b>13</b> Model Diagnostics</a><ul>
<li class="chapter" data-level="13.1" data-path="model-diagnostics.html"><a href="model-diagnostics.html#model-assumptions"><i class="fa fa-check"></i><b>13.1</b> Model Assumptions</a></li>
<li class="chapter" data-level="13.2" data-path="model-diagnostics.html"><a href="model-diagnostics.html#checking-assumptions"><i class="fa fa-check"></i><b>13.2</b> Checking Assumptions</a><ul>
<li class="chapter" data-level="13.2.1" data-path="model-diagnostics.html"><a href="model-diagnostics.html#fitted-versus-residuals-plot"><i class="fa fa-check"></i><b>13.2.1</b> Fitted versus Residuals Plot</a></li>
<li class="chapter" data-level="13.2.2" data-path="model-diagnostics.html"><a href="model-diagnostics.html#breusch-pagan-test"><i class="fa fa-check"></i><b>13.2.2</b> Breusch-Pagan Test</a></li>
<li class="chapter" data-level="13.2.3" data-path="model-diagnostics.html"><a href="model-diagnostics.html#histograms-1"><i class="fa fa-check"></i><b>13.2.3</b> Histograms</a></li>
<li class="chapter" data-level="13.2.4" data-path="model-diagnostics.html"><a href="model-diagnostics.html#q-q-plots"><i class="fa fa-check"></i><b>13.2.4</b> Q-Q Plots</a></li>
<li class="chapter" data-level="13.2.5" data-path="model-diagnostics.html"><a href="model-diagnostics.html#shapiro-wilk-test"><i class="fa fa-check"></i><b>13.2.5</b> Shapiro-Wilk Test</a></li>
</ul></li>
<li class="chapter" data-level="13.3" data-path="model-diagnostics.html"><a href="model-diagnostics.html#unusual-observations"><i class="fa fa-check"></i><b>13.3</b> Unusual Observations</a><ul>
<li class="chapter" data-level="13.3.1" data-path="model-diagnostics.html"><a href="model-diagnostics.html#leverage"><i class="fa fa-check"></i><b>13.3.1</b> Leverage</a></li>
<li class="chapter" data-level="13.3.2" data-path="model-diagnostics.html"><a href="model-diagnostics.html#outliers"><i class="fa fa-check"></i><b>13.3.2</b> Outliers</a></li>
<li class="chapter" data-level="13.3.3" data-path="model-diagnostics.html"><a href="model-diagnostics.html#influence"><i class="fa fa-check"></i><b>13.3.3</b> Influence</a></li>
</ul></li>
<li class="chapter" data-level="13.4" data-path="model-diagnostics.html"><a href="model-diagnostics.html#data-analysis-examples"><i class="fa fa-check"></i><b>13.4</b> Data Analysis Examples</a><ul>
<li class="chapter" data-level="13.4.1" data-path="model-diagnostics.html"><a href="model-diagnostics.html#good-diagnostics"><i class="fa fa-check"></i><b>13.4.1</b> Good Diagnostics</a></li>
<li class="chapter" data-level="13.4.2" data-path="model-diagnostics.html"><a href="model-diagnostics.html#suspect-diagnostics"><i class="fa fa-check"></i><b>13.4.2</b> Suspect Diagnostics</a></li>
</ul></li>
<li class="chapter" data-level="13.5" data-path="model-diagnostics.html"><a href="model-diagnostics.html#r-markdown-6"><i class="fa fa-check"></i><b>13.5</b> <code>R</code> Markdown</a></li>
</ul></li>
<li class="chapter" data-level="14" data-path="transformations.html"><a href="transformations.html"><i class="fa fa-check"></i><b>14</b> Transformations</a><ul>
<li class="chapter" data-level="14.1" data-path="transformations.html"><a href="transformations.html#response-transformation"><i class="fa fa-check"></i><b>14.1</b> Response Transformation</a><ul>
<li class="chapter" data-level="14.1.1" data-path="transformations.html"><a href="transformations.html#variance-stabilizing-transformations"><i class="fa fa-check"></i><b>14.1.1</b> Variance Stabilizing Transformations</a></li>
<li class="chapter" data-level="14.1.2" data-path="transformations.html"><a href="transformations.html#box-cox-transformations"><i class="fa fa-check"></i><b>14.1.2</b> Box-Cox Transformations</a></li>
</ul></li>
<li class="chapter" data-level="14.2" data-path="transformations.html"><a href="transformations.html#predictor-transformation"><i class="fa fa-check"></i><b>14.2</b> Predictor Transformation</a><ul>
<li class="chapter" data-level="14.2.1" data-path="transformations.html"><a href="transformations.html#polynomials"><i class="fa fa-check"></i><b>14.2.1</b> Polynomials</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="transformations.html"><a href="transformations.html#response-transformations"><i class="fa fa-check"></i>Response Transformations</a></li>
<li class="chapter" data-level="" data-path="transformations.html"><a href="transformations.html#predictor-transformations"><i class="fa fa-check"></i>Predictor Transformations</a><ul>
<li class="chapter" data-level="14.2.2" data-path="transformations.html"><a href="transformations.html#a-quadratic-model"><i class="fa fa-check"></i><b>14.2.2</b> A Quadratic Model</a></li>
<li class="chapter" data-level="14.2.3" data-path="transformations.html"><a href="transformations.html#overfitting-and-extrapolation"><i class="fa fa-check"></i><b>14.2.3</b> Overfitting and Extrapolation</a></li>
<li class="chapter" data-level="14.2.4" data-path="transformations.html"><a href="transformations.html#comparing-polynomial-models"><i class="fa fa-check"></i><b>14.2.4</b> Comparing Polynomial Models</a></li>
<li class="chapter" data-level="14.2.5" data-path="transformations.html"><a href="transformations.html#poly-function-and-orthogonal-polynomials"><i class="fa fa-check"></i><b>14.2.5</b> <code>poly()</code> Function and Orthogonal Polynomials</a></li>
<li class="chapter" data-level="14.2.6" data-path="transformations.html"><a href="transformations.html#inhibit-function"><i class="fa fa-check"></i><b>14.2.6</b> Inhibit Function</a></li>
<li class="chapter" data-level="14.2.7" data-path="transformations.html"><a href="transformations.html#data-example"><i class="fa fa-check"></i><b>14.2.7</b> Data Example</a></li>
</ul></li>
<li class="chapter" data-level="14.3" data-path="transformations.html"><a href="transformations.html#r-markdown-7"><i class="fa fa-check"></i><b>14.3</b> <code>R</code> Markdown</a></li>
</ul></li>
<li class="chapter" data-level="15" data-path="collinearity.html"><a href="collinearity.html"><i class="fa fa-check"></i><b>15</b> Collinearity</a><ul>
<li class="chapter" data-level="15.1" data-path="collinearity.html"><a href="collinearity.html#exact-collinearity"><i class="fa fa-check"></i><b>15.1</b> Exact Collinearity</a></li>
<li class="chapter" data-level="15.2" data-path="collinearity.html"><a href="collinearity.html#collinearity-1"><i class="fa fa-check"></i><b>15.2</b> Collinearity</a><ul>
<li class="chapter" data-level="15.2.1" data-path="collinearity.html"><a href="collinearity.html#variance-inflation-factor."><i class="fa fa-check"></i><b>15.2.1</b> Variance Inflation Factor.</a></li>
</ul></li>
<li class="chapter" data-level="15.3" data-path="collinearity.html"><a href="collinearity.html#simulation-2"><i class="fa fa-check"></i><b>15.3</b> Simulation</a></li>
<li class="chapter" data-level="15.4" data-path="collinearity.html"><a href="collinearity.html#r-markdown-8"><i class="fa fa-check"></i><b>15.4</b> <code>R</code> Markdown</a></li>
</ul></li>
<li class="chapter" data-level="16" data-path="variable-selection-and-model-building.html"><a href="variable-selection-and-model-building.html"><i class="fa fa-check"></i><b>16</b> Variable Selection and Model Building</a><ul>
<li class="chapter" data-level="16.1" data-path="variable-selection-and-model-building.html"><a href="variable-selection-and-model-building.html#quality-criterion"><i class="fa fa-check"></i><b>16.1</b> Quality Criterion</a><ul>
<li class="chapter" data-level="16.1.1" data-path="variable-selection-and-model-building.html"><a href="variable-selection-and-model-building.html#akaike-information-criterion"><i class="fa fa-check"></i><b>16.1.1</b> Akaike Information Criterion</a></li>
<li class="chapter" data-level="16.1.2" data-path="variable-selection-and-model-building.html"><a href="variable-selection-and-model-building.html#bayesian-information-criterion"><i class="fa fa-check"></i><b>16.1.2</b> Bayesian Information Criterion</a></li>
<li class="chapter" data-level="16.1.3" data-path="variable-selection-and-model-building.html"><a href="variable-selection-and-model-building.html#adjusted-r-squared"><i class="fa fa-check"></i><b>16.1.3</b> Adjusted R-Squared</a></li>
<li class="chapter" data-level="16.1.4" data-path="variable-selection-and-model-building.html"><a href="variable-selection-and-model-building.html#cross-validated-rmse"><i class="fa fa-check"></i><b>16.1.4</b> Cross-Validated RMSE</a></li>
</ul></li>
<li class="chapter" data-level="16.2" data-path="variable-selection-and-model-building.html"><a href="variable-selection-and-model-building.html#selection-procedures"><i class="fa fa-check"></i><b>16.2</b> Selection Procedures</a><ul>
<li class="chapter" data-level="16.2.1" data-path="variable-selection-and-model-building.html"><a href="variable-selection-and-model-building.html#backward-search"><i class="fa fa-check"></i><b>16.2.1</b> Backward Search</a></li>
<li class="chapter" data-level="16.2.2" data-path="variable-selection-and-model-building.html"><a href="variable-selection-and-model-building.html#forward-search"><i class="fa fa-check"></i><b>16.2.2</b> Forward Search</a></li>
<li class="chapter" data-level="16.2.3" data-path="variable-selection-and-model-building.html"><a href="variable-selection-and-model-building.html#stepwise-search"><i class="fa fa-check"></i><b>16.2.3</b> Stepwise Search</a></li>
<li class="chapter" data-level="16.2.4" data-path="variable-selection-and-model-building.html"><a href="variable-selection-and-model-building.html#exhaustive-search"><i class="fa fa-check"></i><b>16.2.4</b> Exhaustive Search</a></li>
</ul></li>
<li class="chapter" data-level="16.3" data-path="variable-selection-and-model-building.html"><a href="variable-selection-and-model-building.html#higher-order-terms"><i class="fa fa-check"></i><b>16.3</b> Higher Order Terms</a></li>
<li class="chapter" data-level="16.4" data-path="variable-selection-and-model-building.html"><a href="variable-selection-and-model-building.html#explanation-versus-prediction-1"><i class="fa fa-check"></i><b>16.4</b> Explanation versus Prediction</a><ul>
<li class="chapter" data-level="16.4.1" data-path="variable-selection-and-model-building.html"><a href="variable-selection-and-model-building.html#explanation-1"><i class="fa fa-check"></i><b>16.4.1</b> Explanation</a></li>
<li class="chapter" data-level="16.4.2" data-path="variable-selection-and-model-building.html"><a href="variable-selection-and-model-building.html#prediction-1"><i class="fa fa-check"></i><b>16.4.2</b> Prediction</a></li>
</ul></li>
<li class="chapter" data-level="16.5" data-path="variable-selection-and-model-building.html"><a href="variable-selection-and-model-building.html#r-markdown-9"><i class="fa fa-check"></i><b>16.5</b> <code>R</code> Markdown</a></li>
</ul></li>
<li class="chapter" data-level="17" data-path="logistic-regression.html"><a href="logistic-regression.html"><i class="fa fa-check"></i><b>17</b> Logistic Regression</a><ul>
<li class="chapter" data-level="17.1" data-path="logistic-regression.html"><a href="logistic-regression.html#generalized-linear-models"><i class="fa fa-check"></i><b>17.1</b> Generalized Linear Models</a></li>
<li class="chapter" data-level="17.2" data-path="logistic-regression.html"><a href="logistic-regression.html#binary-response"><i class="fa fa-check"></i><b>17.2</b> Binary Response</a><ul>
<li class="chapter" data-level="17.2.1" data-path="logistic-regression.html"><a href="logistic-regression.html#fitting-logistic-regression"><i class="fa fa-check"></i><b>17.2.1</b> Fitting Logistic Regression</a></li>
<li class="chapter" data-level="17.2.2" data-path="logistic-regression.html"><a href="logistic-regression.html#fitting-issues"><i class="fa fa-check"></i><b>17.2.2</b> Fitting Issues</a></li>
<li class="chapter" data-level="17.2.3" data-path="logistic-regression.html"><a href="logistic-regression.html#simulation-examples"><i class="fa fa-check"></i><b>17.2.3</b> Simulation Examples</a></li>
</ul></li>
<li class="chapter" data-level="17.3" data-path="logistic-regression.html"><a href="logistic-regression.html#working-with-logistic-regression"><i class="fa fa-check"></i><b>17.3</b> Working with Logistic Regression</a><ul>
<li class="chapter" data-level="17.3.1" data-path="logistic-regression.html"><a href="logistic-regression.html#testing-with-glms"><i class="fa fa-check"></i><b>17.3.1</b> Testing with GLMs</a></li>
<li class="chapter" data-level="17.3.2" data-path="logistic-regression.html"><a href="logistic-regression.html#wald-test"><i class="fa fa-check"></i><b>17.3.2</b> Wald Test</a></li>
<li class="chapter" data-level="17.3.3" data-path="logistic-regression.html"><a href="logistic-regression.html#likelihood-ratio-test"><i class="fa fa-check"></i><b>17.3.3</b> Likelihood-Ratio Test</a></li>
<li class="chapter" data-level="17.3.4" data-path="logistic-regression.html"><a href="logistic-regression.html#saheart-example"><i class="fa fa-check"></i><b>17.3.4</b> <code>SAheart</code> Example</a></li>
<li class="chapter" data-level="17.3.5" data-path="logistic-regression.html"><a href="logistic-regression.html#confidence-intervals-1"><i class="fa fa-check"></i><b>17.3.5</b> Confidence Intervals</a></li>
<li class="chapter" data-level="17.3.6" data-path="logistic-regression.html"><a href="logistic-regression.html#confidence-intervals-for-mean-response-1"><i class="fa fa-check"></i><b>17.3.6</b> Confidence Intervals for Mean Response</a></li>
<li class="chapter" data-level="17.3.7" data-path="logistic-regression.html"><a href="logistic-regression.html#formula-syntax"><i class="fa fa-check"></i><b>17.3.7</b> Formula Syntax</a></li>
<li class="chapter" data-level="17.3.8" data-path="logistic-regression.html"><a href="logistic-regression.html#deviance"><i class="fa fa-check"></i><b>17.3.8</b> Deviance</a></li>
</ul></li>
<li class="chapter" data-level="17.4" data-path="logistic-regression.html"><a href="logistic-regression.html#classification"><i class="fa fa-check"></i><b>17.4</b> Classification</a><ul>
<li class="chapter" data-level="17.4.1" data-path="logistic-regression.html"><a href="logistic-regression.html#spam-example"><i class="fa fa-check"></i><b>17.4.1</b> <code>spam</code> Example</a></li>
<li class="chapter" data-level="17.4.2" data-path="logistic-regression.html"><a href="logistic-regression.html#evaluating-classifiers"><i class="fa fa-check"></i><b>17.4.2</b> Evaluating Classifiers</a></li>
</ul></li>
<li class="chapter" data-level="17.5" data-path="logistic-regression.html"><a href="logistic-regression.html#r-markdown-10"><i class="fa fa-check"></i><b>17.5</b> <code>R</code> Markdown</a></li>
</ul></li>
<li class="chapter" data-level="18" data-path="beyond.html"><a href="beyond.html"><i class="fa fa-check"></i><b>18</b> Beyond</a><ul>
<li class="chapter" data-level="18.1" data-path="beyond.html"><a href="beyond.html#whats-next"><i class="fa fa-check"></i><b>18.1</b> What’s Next</a></li>
<li class="chapter" data-level="18.2" data-path="beyond.html"><a href="beyond.html#rstudio"><i class="fa fa-check"></i><b>18.2</b> RStudio</a></li>
<li class="chapter" data-level="18.3" data-path="beyond.html"><a href="beyond.html#tidy-data"><i class="fa fa-check"></i><b>18.3</b> Tidy Data</a></li>
<li class="chapter" data-level="18.4" data-path="beyond.html"><a href="beyond.html#visualization"><i class="fa fa-check"></i><b>18.4</b> Visualization</a></li>
<li class="chapter" data-level="18.5" data-path="beyond.html"><a href="beyond.html#web-applications"><i class="fa fa-check"></i><b>18.5</b> Web Applications</a></li>
<li class="chapter" data-level="18.6" data-path="beyond.html"><a href="beyond.html#experimental-design"><i class="fa fa-check"></i><b>18.6</b> Experimental Design</a></li>
<li class="chapter" data-level="18.7" data-path="beyond.html"><a href="beyond.html#machine-learning"><i class="fa fa-check"></i><b>18.7</b> Machine Learning</a><ul>
<li class="chapter" data-level="18.7.1" data-path="beyond.html"><a href="beyond.html#deep-learning"><i class="fa fa-check"></i><b>18.7.1</b> Deep Learning</a></li>
</ul></li>
<li class="chapter" data-level="18.8" data-path="beyond.html"><a href="beyond.html#time-series"><i class="fa fa-check"></i><b>18.8</b> Time Series</a></li>
<li class="chapter" data-level="18.9" data-path="beyond.html"><a href="beyond.html#bayesianism"><i class="fa fa-check"></i><b>18.9</b> Bayesianism</a></li>
<li class="chapter" data-level="18.10" data-path="beyond.html"><a href="beyond.html#high-performance-computing"><i class="fa fa-check"></i><b>18.10</b> High Performance Computing</a></li>
<li class="chapter" data-level="18.11" data-path="beyond.html"><a href="beyond.html#further-r-resources"><i class="fa fa-check"></i><b>18.11</b> Further <code>R</code> Resources</a></li>
</ul></li>
<li class="chapter" data-level="19" data-path="appendix.html"><a href="appendix.html"><i class="fa fa-check"></i><b>19</b> Appendix</a></li>
<li class="divider"></li>
<li><a href="https://github.com/daviddalpiaz/appliedstats" target="blank">&copy; 2016 David Dalpiaz</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Applied Statistics with <code>R</code></a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="logistic-regression" class="section level1">
<h1><span class="header-section-number">Chapter 17</span> Logistic Regression</h1>
<p><strong>Note to current readers:</strong> This chapter is slightly less tested than previous chapters. Please do not hesitate to report any errors, or suggest sections that need better explanation! Also, as a result, this material is more likely to receive edits.</p>
<p>After reading this chapter you will be able to:</p>
<ul>
<li>Understand how generalized linear models are a generalization of ordinary linear models.</li>
<li>Use logistic regression to model a binary response.</li>
<li>Apply concepts learned for ordinary linear models to logistic regression.</li>
<li>Use logistic regression to perform classification.</li>
</ul>
<p>So far we have only considered models for numeric response variables. What about response variables that only take integer values? What about a response variable that is categorical? Can we use linear models in these situations? Yes! The model that we have been using, which we will call <em>ordinary linear regression</em>, is actually a specific case of the more general, <em>generalized linear model</em>. (Aren’t statisticians great at naming things?)</p>
<div id="generalized-linear-models" class="section level2">
<h2><span class="header-section-number">17.1</span> Generalized Linear Models</h2>
<p>So far, we’ve had response variables that, conditioned on the predictors, were modeled using a normal distribution with a mean that is some linear combination of the predictors. This linear combination is what made a linear model “linear.”</p>
<p><span class="math display">\[
Y \mid {\bf X} = {\bf x} \sim N(\beta_0 + \beta_1x_1 + \ldots + \beta_{p - 1}x_{p - 1}, \ \sigma^2)
\]</span></p>
<p>Now we’ll allow for two modifications of this situation, which will let us use linear models in many more situations. Instead of using a normal distribution for the response conditioned on the predictors, we’ll allow for other distributions. Also, instead of the conditional mean being a linear combination of the predictors, it can be some function of a linear combination of the predictors.</p>
<p>In <em>general</em>, a generalized linear model has three parts:</p>
<ul>
<li>A <strong>distribution</strong> of the response conditioned on the predictors. (Technically this distribution needs to be from the <a href="https://en.wikipedia.org/wiki/Exponential_family" target="_blank">exponential family</a> of distributions.)</li>
<li>A <strong>linear combination</strong> of the <span class="math inline">\(p - 1\)</span> predictors, <span class="math inline">\(\beta_0 + \beta_1 x_1 + \beta_2 x_2 + \ldots + \beta_{p - 1} x_{p - 1}\)</span>, which we write as <span class="math inline">\(\eta({\bf x})\)</span>. That is,</li>
</ul>
<p><span class="math display">\[\eta({\bf x}) = \beta_0 + \beta_1 x_1 + \beta_2 x_2 + \ldots  + \beta_{p - 1} x_{p - 1}\]</span></p>
<ul>
<li>A <strong>link</strong> function, <span class="math inline">\(g()\)</span>, that defines how <span class="math inline">\(\eta({\bf x})\)</span>, the linear combination of the predictors, is related to the mean of the response conditioned on the predictors, <span class="math inline">\(\text{E}[Y \mid {\bf X} = {\bf x}]\)</span>.</li>
</ul>
<p><span class="math display">\[
\eta({\bf x}) = g\left(\text{E}[Y \mid {\bf X} = {\bf x}]\right).
\]</span></p>
<p>The following table summarizes three examples of a generalized linear model:</p>
<table>
<colgroup>
<col width="22%" />
<col width="23%" />
<col width="26%" />
<col width="27%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>Linear Regression</th>
<th>Poisson Regression</th>
<th>Logistic Regression</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(Y \mid {\bf X} = {\bf x}\)</span></td>
<td><span class="math inline">\(N(\mu({\bf x}), \sigma^2)\)</span></td>
<td><span class="math inline">\(\text{Pois}(\lambda({\bf x}))\)</span></td>
<td><span class="math inline">\(\text{Bern}(p({\bf x}))\)</span></td>
</tr>
<tr class="even">
<td><strong>Distribution Name</strong></td>
<td>Normal</td>
<td>Poisson</td>
<td>Bernoulli (Binomial)</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\text{E}[Y \mid {\bf X} = {\bf x}]\)</span></td>
<td><span class="math inline">\(\mu({\bf x})\)</span></td>
<td><span class="math inline">\(\lambda({\bf x})\)</span></td>
<td><span class="math inline">\(p({\bf x})\)</span></td>
</tr>
<tr class="even">
<td><strong>Support</strong></td>
<td>Real: <span class="math inline">\((-\infty, \infty)\)</span></td>
<td>Integer: <span class="math inline">\(0, 1, 2, \ldots\)</span></td>
<td>Integer: <span class="math inline">\(0, 1\)</span></td>
</tr>
<tr class="odd">
<td><strong>Usage</strong></td>
<td>Numeric Data</td>
<td>Count (Integer) Data</td>
<td>Binary (Class ) Data</td>
</tr>
<tr class="even">
<td><strong>Link Name</strong></td>
<td>Identity</td>
<td>Log</td>
<td>Logit</td>
</tr>
<tr class="odd">
<td><strong>Link Function</strong></td>
<td><span class="math inline">\(\eta({\bf x}) = \mu({\bf x})\)</span></td>
<td><span class="math inline">\(\eta({\bf x}) = \log(\lambda({\bf x}))\)</span></td>
<td><span class="math inline">\(\eta({\bf x}) = \log \left(\frac{p({\bf x})}{1 - p({\bf x})} \right)\)</span></td>
</tr>
<tr class="even">
<td><strong>Mean Function</strong></td>
<td><span class="math inline">\(\mu({\bf x}) = \eta({\bf x})\)</span></td>
<td><span class="math inline">\(\lambda({\bf x}) = e^{\eta({\bf x})}\)</span></td>
<td><span class="math inline">\(p({\bf x}) = \frac{e^{\eta({\bf x})}}{1 + e^{\eta({\bf x})}} = \frac{1}{1 + e^{-\eta({\bf x})}}\)</span></td>
</tr>
</tbody>
</table>
<p>Like ordinary linear regression, we will seek to “fit” the model by estimating the <span class="math inline">\(\beta\)</span> parameters. To do so, we will use the method of maximum likelihood.</p>
<p>Note that a Bernoulli distribution is a specific case of a binomial distribution where the <span class="math inline">\(n\)</span> parameter of a binomial is <span class="math inline">\(1\)</span>. Binomial regression is also possible, but we’ll focus on the much more popular Bernoulli case.</p>
<p>So, in general, GLMs relate the mean of the response to a linear combination of the predictors, <span class="math inline">\(\eta({\bf x})\)</span>, through the use of a link function, <span class="math inline">\(g()\)</span>. That is,</p>
<p><span class="math display">\[
\eta({\bf x}) = g\left(\text{E}[Y \mid {\bf X} = {\bf x}]\right).
\]</span></p>
<p>The mean is then</p>
<p><span class="math display">\[
\text{E}[Y \mid {\bf X} = {\bf x}] = g^{-1}(\eta({\bf x})).
\]</span></p>
</div>
<div id="binary-response" class="section level2">
<h2><span class="header-section-number">17.2</span> Binary Response</h2>
<p>To illustrate the use of a GLM we’ll focus on the case of binary responses variable coded using <span class="math inline">\(0\)</span> and <span class="math inline">\(1\)</span>. In practice, these <span class="math inline">\(0\)</span> and <span class="math inline">\(1\)</span>s will code for two classes such as yes/no, cat/dog, sick/healthy, etc.</p>
<p><span class="math display">\[
Y = 
\begin{cases} 
      1 &amp; \text{yes} \\
      0 &amp; \text{no} 
\end{cases}
\]</span></p>
<p>First, we define some notation that we will use throughout.</p>
<p><span class="math display">\[
p({\bf x}) = P[Y = 1 \mid {\bf X} = {\bf x}]
\]</span></p>
<p>With a binary (Bernoulli) response, we’ll mostly focus on the case when <span class="math inline">\(Y = 1\)</span>, since with only two possibilities, it is trivial to obtain probabilities when <span class="math inline">\(Y = 0\)</span>.</p>
<p><span class="math display">\[
P[Y = 0 \mid {\bf X} = {\bf x}] + P[Y = 1 \mid {\bf X} = {\bf x}] = 1
\]</span></p>
<p><span class="math display">\[
P[Y = 0 \mid {\bf X} = {\bf x}] = 1 - p({\bf x})
\]</span></p>
<p>We now define the <strong>logistic regression</strong> model.</p>
<p><span class="math display">\[
\log\left(\frac{p({\bf x})}{1 - p({\bf x})}\right) = \beta_0 + \beta_1 x_1 + \ldots  + \beta_{p - 1} x_{p - 1}
\]</span></p>
<p>Immediately we notice some similarities to ordinary linear regression, in particular, the right hand side. This is our usual linear combination of the predictors. We have our usual <span class="math inline">\(p - 1\)</span> predictors for a total of <span class="math inline">\(p\)</span> <span class="math inline">\(\beta\)</span> parameters. (Note, many more machine learning focused texts will use <span class="math inline">\(p\)</span> as the number of parameters. This is an arbitrary choice, but you should be aware of it.)</p>
<p>The right hand side is called the <strong>log odds</strong>, which is the log of the odds. The odds are the probability for a positive event <span class="math inline">\((Y = 1)\)</span> divided by the probability of a negative event <span class="math inline">\((Y = 0)\)</span>. So when the odds are <span class="math inline">\(1\)</span>, the two events have equal probability. Odds greater than <span class="math inline">\(1\)</span> favor a positive event. The opposite is true when the odds are less than <span class="math inline">\(1\)</span>.</p>
<p><span class="math display">\[
\frac{p({\bf x})}{1 - p({\bf x})} = \frac{P[Y = 1 \mid {\bf X} = {\bf x}]}{P[Y = 0 \mid {\bf X} = {\bf x}]}
\]</span></p>
<p>Essentially, the log odds are the <a href="https://en.wikipedia.org/wiki/Logit" target="_blank">logit</a> transform applied to <span class="math inline">\(p({\bf x})\)</span>.</p>
<p><span class="math display">\[
\text{logit}(\xi) = \log\left(\frac{\xi}{1 - \xi}\right)
\]</span></p>
<p>It will also be useful to define the inverse logit, otherwise known as the “logistic” or <a href="https://en.wikipedia.org/wiki/Sigmoid_function" target="_blank">sigmoid</a> function.</p>
<p><span class="math display">\[
\text{logit}^{-1}(\xi) = \frac{e^\xi}{1 + e^{\xi}} = \frac{1}{1 + e^{-\xi}}
\]</span></p>
<p>Note that for <span class="math inline">\(x \in (-\infty, \infty))\)</span>, this function outputs values between 0 and 1.</p>
<p>Students often ask, where is the error term? The answer is that its something that is specific to the normal model. First notice that the model with the error term,</p>
<p><span class="math display">\[
Y = \beta_0 + \beta_1x_1 + \ldots + \beta_qx_q + \epsilon, \ \ \epsilon \sim N(0, \sigma^2)
\]</span>
can instead be written as</p>
<p><span class="math display">\[
Y \mid {\bf X} = {\bf x} \sim N(\beta_0 + \beta_1x_1 + \ldots + \beta_qx_q, \ \sigma^2).
\]</span></p>
<p>While our main focus is on estimating the mean, <span class="math inline">\(\beta_0 + \beta_1x_1 + \ldots + \beta_qx_q\)</span>, there is also another parameter, <span class="math inline">\(\sigma^2\)</span> which needs to be estimated. This is the result of the normal distribution having two parameters.</p>
<p>With logistic regression, which uses the Bernoulli distribution, we only need to estimate the Bernoulli distribution’s single parameter <span class="math inline">\(p({\bf x})\)</span>, which happens to be its mean.</p>
<p><span class="math display">\[
\log\left(\frac{p({\bf x})}{1 - p({\bf x})}\right) = \beta_0 + \beta_1 x_1 + \ldots  + \beta_{q} x_{q}
\]</span></p>
<p>So even though we introduced ordinary linear regression first, in some ways, logistic regression is actually simpler.</p>
<p>Note that applying the inverse logit transformation allow us to obtain an expression for <span class="math inline">\(p({\bf x})\)</span>.</p>
<p><span class="math display">\[
p({\bf x}) = P[Y = 1 \mid {\bf X} = {\bf x}] = \frac{e^{\beta_0 + \beta_1 x_{1} + \cdots + \beta_{p-1} x_{(p-1)}}}{1 + e^{\beta_0 + \beta_1 x_{1} + \cdots + \beta_{p-1} x_{(p-1)}}}
\]</span></p>
<div id="fitting-logistic-regression" class="section level3">
<h3><span class="header-section-number">17.2.1</span> Fitting Logistic Regression</h3>
<p>With <span class="math inline">\(n\)</span> observations, we write the model indexed with <span class="math inline">\(i\)</span> to note that it is being applied to each observation.</p>
<p><span class="math display">\[
\log\left(\frac{p({\bf x_i})}{1 - p({\bf x_i)})}\right) = \beta_0 + \beta_1 x_{i1} + \cdots + \beta_{p-1} x_{i(p-1)}
\]</span></p>
<p>We can apply the inverse logit transformation to obtain <span class="math inline">\(P[Y_i = 1 \mid {\bf X_i} = {\bf x_i}]\)</span> for each observation. Since these are probabilities, it’s good that we used a function that returns values between <span class="math inline">\(0\)</span> and <span class="math inline">\(1\)</span>.</p>
<p><span class="math display">\[
p({\bf x_i}) = P[Y_i = 1 \mid {\bf X_i} = {\bf x_i}] = \frac{e^{\beta_0 + \beta_1 x_{i1} + \cdots + \beta_{p-1} x_{i(p-1)}}}{1 + e^{\beta_0 + \beta_1 x_{i1} + \cdots + \beta_{p-1} x_{i(p-1)}}}
\]</span></p>
<p><span class="math display">\[
1 - p({\bf x_i}) = P[Y_i = 0 \mid {\bf X} = {\bf x_i}] = \frac{1}{1 + e^{\beta_0 + \beta_1 x_{i1} + \cdots + \beta_{p-1} x_{i(p-1)}}}
\]</span></p>
<p>To “fit” this model, that is estimate the <span class="math inline">\(\beta\)</span> parameters, we will use maximum likelihood.</p>
<p><span class="math display">\[
\boldsymbol{{\beta}} = [\beta_0, \beta_1, \beta_2, \beta_3, \ldots \beta_{p - 1}]
\]</span></p>
<p>We first write the likelihood given the observed data.</p>
<p><span class="math display">\[
L(\boldsymbol{{\beta}}) = \prod_{i = 1}^{n} P[Y_i = y_i \mid {\bf X_i} = {\bf x_i}]
\]</span></p>
<p>This is already technically a function of the <span class="math inline">\(\beta\)</span> parameters, but we’ll do some rearrangement to make this more explicit.</p>
<p><span class="math display">\[
L(\boldsymbol{{\beta}}) = \prod_{i = 1}^{n} p({\bf x_i})^{y_i} (1 - p({\bf x_i}))^{(1 - y_i)}
\]</span></p>
<p><span class="math display">\[
L(\boldsymbol{{\beta}}) = \prod_{i : y_i = 1}^{n} p({\bf x_i}) \prod_{j : y_j = 0}^{n} (1 - p({\bf x_j}))
\]</span></p>
<p><span class="math display">\[
L(\boldsymbol{{\beta}}) = \prod_{i : y_i = 1}^{} \frac{e^{\beta_0 + \beta_1 x_{i1} + \cdots + \beta_{p-1} x_{i(p-1)}}}{1 + e^{\beta_0 + \beta_1 x_{i1} + \cdots + \beta_{p-1} x_{i(p-1)}}} \prod_{j : y_j = 0}^{} \frac{1}{1 + e^{\beta_0 + \beta_1 x_{j1} + \cdots + \beta_{p-1} x_{j(p-1)}}}
\]</span></p>
<p>Unfortunately, unlike ordinary linear regression, there is no analytical solution for this maximization problem. Instead, it will need to be solved numerically. Fortunately, <code>R</code> will take care of this for us using an iteratively reweighted least squares algorithm. (We’ll leave the details for a machine learning or optimization course, which would likely also discuss alternative optimization strategies.)</p>
</div>
<div id="fitting-issues" class="section level3">
<h3><span class="header-section-number">17.2.2</span> Fitting Issues</h3>
<p>We should note that, if there exists some <span class="math inline">\(\beta^*\)</span> such that</p>
<p><span class="math display">\[
{\bf x_i}^{\top} \boldsymbol{{\beta}^*} &gt; 0 \implies y_i = 1
\]</span></p>
<p>and</p>
<p><span class="math display">\[
{\bf x_i}^{\top} \boldsymbol{{\beta}^*} &lt; 0 \implies y_i = 0
\]</span></p>
<p>for all observations, then the MLE is not unique. Such data is said to be separable.</p>
<p>This, and similar numeric issues related to estimated probabilities near 0 or 1, will return a warning in <code>R</code>:</p>
<pre><code>## Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred</code></pre>
<p>When this happens, the model is still “fit,” but there are consequences, namely, the estimated coefficients are highly suspect. This is an issue when then trying to interpret the model. When this happens, the model will often still be useful for creating a classifier, which will be discussed later. However, it is still subject to the usual evaluations for classifiers to determine how well it is performing. For details, see <a href="https://link.springer.com/content/pdf/10.1007/978-1-4757-2719-7_7.pdf" target="_blank">Modern Applied Statistics with S-PLUS, Chapter 7</a>.</p>
</div>
<div id="simulation-examples" class="section level3">
<h3><span class="header-section-number">17.2.3</span> Simulation Examples</h3>
<pre class="sourceCode r"><code class="sourceCode r">sim_logistic_data =<span class="st"> </span><span class="cf">function</span>(<span class="dt">sample_size =</span> <span class="dv">25</span>, <span class="dt">beta_0 =</span> <span class="dv">-2</span>, <span class="dt">beta_1 =</span> <span class="dv">3</span>) {
  x =<span class="st"> </span><span class="kw">rnorm</span>(<span class="dt">n =</span> sample_size)
  eta =<span class="st"> </span>beta_<span class="dv">0</span> <span class="op">+</span><span class="st"> </span>beta_<span class="dv">1</span> <span class="op">*</span><span class="st"> </span>x
  p =<span class="st"> </span><span class="dv">1</span> <span class="op">/</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="kw">exp</span>(<span class="op">-</span>eta))
  y =<span class="st"> </span><span class="kw">rbinom</span>(<span class="dt">n =</span> sample_size, <span class="dt">size =</span> <span class="dv">1</span>, <span class="dt">prob =</span> p)
  <span class="kw">data.frame</span>(y, x)
}</code></pre>
<p>You might think, why not simply use ordinary linear regression? Even with a binary response, our goal is still to model (some function of) <span class="math inline">\(\text{E}[Y \mid {\bf X} = {\bf x}]\)</span>. However, with a binary response coded as <span class="math inline">\(0\)</span> and <span class="math inline">\(1\)</span>, <span class="math inline">\(\text{E}[Y \mid {\bf X} = {\bf x}] = P[Y = 1 \mid {\bf X} = {\bf x}]\)</span> since</p>
<p><span class="math display">\[
\begin{aligned}
\text{E}[Y \mid {\bf X} = {\bf x}] &amp;=  1 \cdot P[Y = 1 \mid {\bf X} = {\bf x}] + 0 \cdot P[Y = 0 \mid {\bf X} = {\bf x}] \\
                                  &amp;= P[Y = 1 \mid {\bf X} = {\bf x}]
\end{aligned}
\]</span></p>
<p>Then why can’t we just use ordinary linear regression to estimate <span class="math inline">\(\text{E}[Y \mid {\bf X} = {\bf x}]\)</span>, and thus <span class="math inline">\(P[Y = 1 \mid {\bf X} = {\bf x}]\)</span>?</p>
<p>To investigate, let’s simulate data from the following model:</p>
<p><span class="math display">\[
\log\left(\frac{p({\bf x})}{1 - p({\bf x})}\right) = -2 + 3 x
\]</span></p>
<p>Another way to write this, which is better matches the function we’re using to simulate the data:</p>
<p><span class="math display">\[
\begin{aligned}
Y_i \mid {\bf X_i} = {\bf x_i} &amp;\sim \text{Bern}(p_i) \\
p_i &amp;= p({\bf x_i}) = \frac{1}{1 + e^{-\eta({\bf x_i})}} \\
\eta({\bf x_i}) &amp;= -2 + 3 x_i
\end{aligned}
\]</span></p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">1</span>)
example_data =<span class="st"> </span><span class="kw">sim_logistic_data</span>()
<span class="kw">head</span>(example_data)</code></pre>
<pre><code>##   y          x
## 1 0 -0.6264538
## 2 1  0.1836433
## 3 0 -0.8356286
## 4 1  1.5952808
## 5 0  0.3295078
## 6 0 -0.8204684</code></pre>
<p>After simulating a dataset, we’ll then fit both ordinary linear regression and logistic regression. Notice that currently the responses variable <code>y</code> is a numeric variable that only takes values <code>0</code> and <code>1</code>. Later we’ll see that we can also fit logistic regression when the response is a factor variable with only two levels. (Generally, having a factor response is preferred, but having a dummy response allows use to make the comparison to using ordinary linear regression.)</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># ordinary linear regression</span>
fit_lm  =<span class="st"> </span><span class="kw">lm</span>(y <span class="op">~</span><span class="st"> </span>x, <span class="dt">data =</span> example_data)
<span class="co"># logistic regression</span>
fit_glm =<span class="st"> </span><span class="kw">glm</span>(y <span class="op">~</span><span class="st"> </span>x, <span class="dt">data =</span> example_data, <span class="dt">family =</span> binomial)</code></pre>
<p>Notice that the syntax is extremely similar. What’s changed?</p>
<ul>
<li><code>lm()</code> has become <code>glm()</code></li>
<li>We’ve added <code>family = binomial</code> argument</li>
</ul>
<p>In a lot of ways, <code>lm()</code> is just a more specific version of <code>glm()</code>. For example</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">glm</span>(y <span class="op">~</span><span class="st"> </span>x, <span class="dt">data =</span> example_data)</code></pre>
<p>would actually fit the ordinary linear regression that we have seen in the past. By default, <code>glm()</code> uses <code>family = gaussian</code> argument. That is, we’re fitting a GLM with a normally distributed response and the identity function as the link.</p>
<p>The <code>family</code> argument to <code>glm()</code> actually specifies both the distribution and the link function. If not made explicit, the link function is chosen to be the <strong>canonical link function</strong>, which is essentially the most mathematical convenient link function. See <code>?glm</code> and <code>?family</code> for details. For example, the following code explicitly specifies the link function which was previously used by default.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># more detailed call to glm for logistic regression</span>
fit_glm =<span class="st"> </span><span class="kw">glm</span>(y <span class="op">~</span><span class="st"> </span>x, <span class="dt">data =</span> example_data, <span class="dt">family =</span> <span class="kw">binomial</span>(<span class="dt">link =</span> <span class="st">&quot;logit&quot;</span>))</code></pre>
<p>Making predictions with an object of type <code>glm</code> is slightly different than making predictions after fitting with <code>lm()</code>. In the case of logistic regression, with <code>family = binomial</code>, we have:</p>
<table>
<colgroup>
<col width="66%" />
<col width="33%" />
</colgroup>
<thead>
<tr class="header">
<th><code>type</code></th>
<th>Returned</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>&quot;link&quot;</code> [default]</td>
<td><span class="math inline">\(\hat{\eta}({\bf x}) = \log\left(\frac{\hat{p}({\bf x})}{1 - \hat{p}({\bf x})}\right)\)</span></td>
</tr>
<tr class="even">
<td><code>&quot;response&quot;</code></td>
<td><span class="math inline">\(\hat{p}({\bf x}) = \frac{e^{\hat{\eta}({\bf x})}}{1 + e^{\hat{\eta}({\bf x})}} = \frac{1}{1 + e^{-\hat{\eta}({\bf x})}}\)</span></td>
</tr>
</tbody>
</table>
<p>That is, <code>type = &quot;link&quot;</code> will get you the log odds, while <code>type = &quot;response&quot;</code> will return the estimated mean, in this case, <span class="math inline">\(P[Y = 1 \mid {\bf X} = {\bf x}]\)</span> for each observation.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(y <span class="op">~</span><span class="st"> </span>x, <span class="dt">data =</span> example_data, 
     <span class="dt">pch =</span> <span class="dv">20</span>, <span class="dt">ylab =</span> <span class="st">&quot;Estimated Probability&quot;</span>, 
     <span class="dt">main =</span> <span class="st">&quot;Ordinary vs Logistic Regression&quot;</span>)
<span class="kw">grid</span>()
<span class="kw">abline</span>(fit_lm, <span class="dt">col =</span> <span class="st">&quot;darkorange&quot;</span>)
<span class="kw">curve</span>(<span class="kw">predict</span>(fit_glm, <span class="kw">data.frame</span>(x), <span class="dt">type =</span> <span class="st">&quot;response&quot;</span>), 
      <span class="dt">add =</span> <span class="ot">TRUE</span>, <span class="dt">col =</span> <span class="st">&quot;dodgerblue&quot;</span>, <span class="dt">lty =</span> <span class="dv">2</span>)
<span class="kw">legend</span>(<span class="st">&quot;topleft&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;Ordinary&quot;</span>, <span class="st">&quot;Logistic&quot;</span>, <span class="st">&quot;Data&quot;</span>), <span class="dt">lty =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">0</span>), 
       <span class="dt">pch =</span> <span class="kw">c</span>(<span class="ot">NA</span>, <span class="ot">NA</span>, <span class="dv">20</span>), <span class="dt">lwd =</span> <span class="dv">2</span>, <span class="dt">col =</span> <span class="kw">c</span>(<span class="st">&quot;darkorange&quot;</span>, <span class="st">&quot;dodgerblue&quot;</span>, <span class="st">&quot;black&quot;</span>))</code></pre>
<p><img src="logistic_files/figure-html/unnamed-chunk-8-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Since we only have a single predictor variable, we are able to graphically show this situation. First, note that the data, is plotted using black dots. The response <code>y</code> only takes values <code>0</code> and <code>1</code>.</p>
<p>Next, we need to discuss the two added lines to the plot. The first, the solid orange line, is the fitted ordinary linear regression.</p>
<p>The dashed blue curve is the estimated logistic regression. It is helpful to realize that we are not plotting an estimate of <span class="math inline">\(Y\)</span> for either. (Sometimes it might seem that way with ordinary linear regression, but that isn’t what is happening.) For both, we are plotting <span class="math inline">\(\hat{\text{E}}[Y \mid {\bf X} = {\bf x}]\)</span>, the estimated mean, which for a binary response happens to be an estimate of <span class="math inline">\(P[Y = 1 \mid {\bf X} = {\bf x}]\)</span>.</p>
<p>We immediately see why ordinary linear regression is not a good idea. While it is estimating the mean, we see that it produces estimates that are less than 0! (And in other situations could produce estimates greater than 1!) If the mean is a probability, we don’t want probabilities less than 0 or greater than 1.</p>
<p>Enter logistic regression. Since the output of the inverse logit function is restricted to be between 0 and 1, our estimates make much more sense as probabilities. Let’s look at our estimated coefficients. (With a lot of rounding, for simplicity.)</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">round</span>(<span class="kw">coef</span>(fit_glm), <span class="dv">1</span>)</code></pre>
<pre><code>## (Intercept)           x 
##        -2.3         3.7</code></pre>
<p>Our estimated model is then:</p>
<p><span class="math display">\[
\log\left(\frac{\hat{p}({\bf x})}{1 - \hat{p}({\bf x})}\right) = -2.3 + 3.7 x
\]</span></p>
<p>Because we’re not directly estimating the mean, but instead a function of the mean, we need to be careful with our interpretation of <span class="math inline">\(\hat{\beta}_1 = 3.7\)</span>. This means that, for a one unit increase in <span class="math inline">\(x\)</span>, the log odds change (in this case increase) by <span class="math inline">\(3.7\)</span>. Also, since <span class="math inline">\(\hat{\beta}_1\)</span> is positive, as we increase <span class="math inline">\(x\)</span> we also increase <span class="math inline">\(\hat{p}({\bf x})\)</span>. To see how much, we have to consider the inverse logistic function.</p>
<p>For example, we have:</p>
<p><span class="math display">\[
\hat{P}[Y = 1 \mid X = -0.5] = \frac{e^{-2.3 + 3.7 \cdot (-0.5)}}{1 + e^{-2.3 + 3.7 \cdot (-0.5)}} \approx 0.016
\]</span></p>
<p><span class="math display">\[
\hat{P}[Y = 1 \mid X = 0] = \frac{e^{-2.3 + 3.7 \cdot (0)}}{1 + e^{-2.3 + 3.7 \cdot (0)}} \approx 0.09112296
\]</span></p>
<p><span class="math display">\[
\hat{P}[Y = 1 \mid X = 1] = \frac{e^{-2.3 + 3.7 \cdot (1)}}{1 + e^{-2.3 + 3.7 \cdot (1)}} \approx 0.8021839
\]</span></p>
<p>Now that we know we should use logistic regression, and not ordinary linear regression, let’s consider another example. This time, let’s consider the model</p>
<p><span class="math display">\[
\log\left(\frac{p({\bf x})}{1 - p({\bf x})}\right) = 1 + -4 x.
\]</span></p>
<p>Again, we could re-write this to better match the function we’re using to simulate the data:</p>
<p><span class="math display">\[
\begin{aligned}
Y_i \mid {\bf X_i} = {\bf x_i} &amp;\sim \text{Bern}(p_i) \\
p_i &amp;= p({\bf x_i}) = \frac{1}{1 + e^{-\eta({\bf x_i})}} \\
\eta({\bf x_i}) &amp;= 1 + -4 x_i
\end{aligned}
\]</span></p>
<p>In this model, as <span class="math inline">\(x\)</span> increases, the log odds decrease.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">1</span>)
example_data =<span class="st"> </span><span class="kw">sim_logistic_data</span>(<span class="dt">sample_size =</span> <span class="dv">50</span>, <span class="dt">beta_0 =</span> <span class="dv">1</span>, <span class="dt">beta_1 =</span> <span class="dv">-4</span>)</code></pre>
<p>We again simulate some observations form this model, then fit logistic regression.</p>
<pre class="sourceCode r"><code class="sourceCode r">fit_glm =<span class="st"> </span><span class="kw">glm</span>(y <span class="op">~</span><span class="st"> </span>x, <span class="dt">data =</span> example_data, <span class="dt">family =</span> binomial)</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(y <span class="op">~</span><span class="st"> </span>x, <span class="dt">data =</span> example_data, 
     <span class="dt">pch =</span> <span class="dv">20</span>, <span class="dt">ylab =</span> <span class="st">&quot;Estimated Probability&quot;</span>, 
     <span class="dt">main =</span> <span class="st">&quot;Logistic Regression, Decreasing Probability&quot;</span>)
<span class="kw">grid</span>()
<span class="kw">curve</span>(<span class="kw">predict</span>(fit_glm, <span class="kw">data.frame</span>(x), <span class="dt">type =</span> <span class="st">&quot;response&quot;</span>), 
      <span class="dt">add =</span> <span class="ot">TRUE</span>, <span class="dt">col =</span> <span class="st">&quot;dodgerblue&quot;</span>, <span class="dt">lty =</span> <span class="dv">2</span>)
<span class="kw">legend</span>(<span class="st">&quot;bottomleft&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;Estimated Probability&quot;</span>, <span class="st">&quot;Data&quot;</span>), <span class="dt">lty =</span> <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">0</span>), 
       <span class="dt">pch =</span> <span class="kw">c</span>(<span class="ot">NA</span>, <span class="dv">20</span>), <span class="dt">lwd =</span> <span class="dv">2</span>, <span class="dt">col =</span> <span class="kw">c</span>(<span class="st">&quot;dodgerblue&quot;</span>, <span class="st">&quot;black&quot;</span>))</code></pre>
<p><img src="logistic_files/figure-html/unnamed-chunk-12-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>We see that this time, as <span class="math inline">\(x\)</span> increases, <span class="math inline">\(\hat{p}({\bf x})\)</span> decreases.</p>
<p>Now let’s look at an example where the estimated probability doesn’t always simply increase or decrease. Much like ordinary linear regression, the linear combination of predictors can contain transformations of predictors (in this case a quadratic term) and interactions.</p>
<pre class="sourceCode r"><code class="sourceCode r">sim_quadratic_logistic_data =<span class="st"> </span><span class="cf">function</span>(<span class="dt">sample_size =</span> <span class="dv">25</span>) {
  x =<span class="st"> </span><span class="kw">rnorm</span>(<span class="dt">n =</span> sample_size)
  eta =<span class="st"> </span><span class="fl">-1.5</span> <span class="op">+</span><span class="st"> </span><span class="fl">0.5</span> <span class="op">*</span><span class="st"> </span>x <span class="op">+</span><span class="st"> </span>x <span class="op">^</span><span class="st"> </span><span class="dv">2</span>
  p =<span class="st"> </span><span class="dv">1</span> <span class="op">/</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="kw">exp</span>(<span class="op">-</span>eta))
  y =<span class="st"> </span><span class="kw">rbinom</span>(<span class="dt">n =</span> sample_size, <span class="dt">size =</span> <span class="dv">1</span>, <span class="dt">prob =</span> p)
  <span class="kw">data.frame</span>(y, x)
}</code></pre>
<p><span class="math display">\[
\log\left(\frac{p({\bf x})}{1 - p({\bf x})}\right) = -1.5 + 0.5x + x^2.
\]</span></p>
<p>Again, we could re-write this to better match the function we’re using to simulate the data:</p>
<p><span class="math display">\[
\begin{aligned}
Y_i \mid {\bf X_i} = {\bf x_i} &amp;\sim \text{Bern}(p_i) \\
p_i &amp;= p({\bf x_i}) = \frac{1}{1 + e^{-\eta({\bf x_i})}} \\
\eta({\bf x_i}) &amp;= -1.5 + 0.5x_i + x_i^2
\end{aligned}
\]</span></p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">42</span>)
example_data =<span class="st"> </span><span class="kw">sim_quadratic_logistic_data</span>(<span class="dt">sample_size =</span> <span class="dv">50</span>)</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">fit_glm =<span class="st"> </span><span class="kw">glm</span>(y <span class="op">~</span><span class="st"> </span>x <span class="op">+</span><span class="st"> </span><span class="kw">I</span>(x<span class="op">^</span><span class="dv">2</span>), <span class="dt">data =</span> example_data, <span class="dt">family =</span> binomial)</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(y <span class="op">~</span><span class="st"> </span>x, <span class="dt">data =</span> example_data, 
     <span class="dt">pch =</span> <span class="dv">20</span>, <span class="dt">ylab =</span> <span class="st">&quot;Estimated Probability&quot;</span>, 
     <span class="dt">main =</span> <span class="st">&quot;Logistic Regression, Quadratic Relationship&quot;</span>)
<span class="kw">grid</span>()
<span class="kw">curve</span>(<span class="kw">predict</span>(fit_glm, <span class="kw">data.frame</span>(x), <span class="dt">type =</span> <span class="st">&quot;response&quot;</span>), 
      <span class="dt">add =</span> <span class="ot">TRUE</span>, <span class="dt">col =</span> <span class="st">&quot;dodgerblue&quot;</span>, <span class="dt">lty =</span> <span class="dv">2</span>)
<span class="kw">legend</span>(<span class="st">&quot;left&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;Prob&quot;</span>, <span class="st">&quot;Data&quot;</span>), <span class="dt">lty =</span> <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">0</span>), 
       <span class="dt">pch =</span> <span class="kw">c</span>(<span class="ot">NA</span>, <span class="dv">20</span>), <span class="dt">lwd =</span> <span class="dv">2</span>, <span class="dt">col =</span> <span class="kw">c</span>(<span class="st">&quot;dodgerblue&quot;</span>, <span class="st">&quot;black&quot;</span>))</code></pre>
<p><img src="logistic_files/figure-html/unnamed-chunk-16-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
</div>
<div id="working-with-logistic-regression" class="section level2">
<h2><span class="header-section-number">17.3</span> Working with Logistic Regression</h2>
<p>While the logistic regression model isn’t exactly the same as the ordinary linear regression model, because they both use a <strong>linear</strong> combination of the predictors</p>
<p><span class="math display">\[
\eta({\bf x}) = \beta_0 + \beta_1 x_1 + \beta_2 x_2 + \ldots  + \beta_{p - 1} x_{p - 1}
\]</span></p>
<p>working with logistic regression is very similar. Many of the things we did with ordinary linear regression can be done with logistic regression in a very similar fashion. For example,</p>
<ul>
<li>Testing for a single <span class="math inline">\(\beta\)</span> parameter</li>
<li>Testing for a set of <span class="math inline">\(\beta\)</span> parameters</li>
<li>Formula specification in <code>R</code></li>
<li>Interpreting parameters and estimates</li>
<li>Confidence intervals for parameters</li>
<li>Confidence intervals for mean response</li>
<li>Variable selection</li>
</ul>
<p>After some introduction to the new tests, we’ll demonstrate each of these using an example.</p>
<div id="testing-with-glms" class="section level3">
<h3><span class="header-section-number">17.3.1</span> Testing with GLMs</h3>
<p>Like ordinary linear regression, we’ll want to be able to perform hypothesis testing. We’ll again want both single parameter, and multiple parameter tests.</p>
</div>
<div id="wald-test" class="section level3">
<h3><span class="header-section-number">17.3.2</span> Wald Test</h3>
<p>In ordinary linear regression, we performed the test of</p>
<p><span class="math display">\[
H_0: \beta_j = 0 \quad \text{vs} \quad H_1: \beta_j \neq 0
\]</span></p>
<p>using a <span class="math inline">\(t\)</span>-test.</p>
<p>For the logistic regression model,</p>
<p><span class="math display">\[
\log\left(\frac{p({\bf x})}{1 - p({\bf x})}\right) = \beta_0 + \beta_1 x_1 + \ldots  + \beta_{p - 1} x_{p - 1}
\]</span></p>
<p>we can again perform a test of</p>
<p><span class="math display">\[
H_0: \beta_j = 0 \quad \text{vs} \quad H_1: \beta_j \neq 0
\]</span></p>
<p>however, the test statistic and its distribution are no longer <span class="math inline">\(t\)</span>. We see that the test statistic takes the same form</p>
<p><span class="math display">\[
z = \frac{\hat{\beta}_j - \beta_j}{\text{SE}[\hat{\beta}_j]} \overset{\text{approx}}{\sim} N(0, 1)
\]</span></p>
<p>but now we are performing a <span class="math inline">\(z\)</span>-test, as the test statistic is approximated by a standard normal distribution, <em>provided we have a large enough sample</em>. (The <span class="math inline">\(t\)</span>-test for ordinary linear regression, assuming the assumptions were correct, had an exact distribution for any sample size.)</p>
<p>We’ll skip some of the exact details of the calculations, as <code>R</code> will obtain the standard error for us. The use of this test will be extremely similar to the <span class="math inline">\(t\)</span>-test for ordinary linear regression. Essentially the only thing that changes is the distribution of the test statistic.</p>
</div>
<div id="likelihood-ratio-test" class="section level3">
<h3><span class="header-section-number">17.3.3</span> Likelihood-Ratio Test</h3>
<p>Consider the following <strong>full</strong> model,</p>
<p><span class="math display">\[
\log\left(\frac{p({\bf x_i})}{1 - p({\bf x_i})}\right) = \beta_0 + \beta_1 x_{i1} + \beta_2 x_{i2} + \cdots + \beta_{(p-1)} x_{i(p-1)} + \epsilon_i
\]</span></p>
<p>This model has <span class="math inline">\(p - 1\)</span> predictors, for a total of <span class="math inline">\(p\)</span> <span class="math inline">\(\beta\)</span>-parameters. We will denote the MLE of these <span class="math inline">\(\beta\)</span>-parameters as <span class="math inline">\(\hat{\beta}_{\text{Full}}\)</span></p>
<p>Now consider a <strong>null</strong> (or <strong>reduced</strong>) model,</p>
<p><span class="math display">\[
\log\left(\frac{p({\bf x_i})}{1 - p({\bf x_i})}\right) = \beta_0 + \beta_1 x_{i1} + \beta_2 x_{i2} + \cdots + \beta_{(q-1)} x_{i(q-1)} + \epsilon_i
\]</span></p>
<p>where <span class="math inline">\(q &lt; p\)</span>. This model has <span class="math inline">\(q - 1\)</span> predictors, for a total of <span class="math inline">\(q\)</span> <span class="math inline">\(\beta\)</span>-parameters. We will denote the MLE of these <span class="math inline">\(\beta\)</span>-parameters as <span class="math inline">\(\hat{\beta}_{\text{Null}}\)</span></p>
<p>The difference between these two models can be codified by the null hypothesis of a test.</p>
<p><span class="math display">\[
H_0: \beta_q = \beta_{q+1} = \cdots = \beta_{p - 1} = 0.
\]</span></p>
<p>This implies that the reduced model is nested inside the full model.</p>
<p>We then define a test statistic, <span class="math inline">\(D\)</span>,</p>
<p><span class="math display">\[
D = -2 \log \left( \frac{L(\boldsymbol{\hat{\beta}_{\text{Null}}})} {L(\boldsymbol{\hat{\beta}_{\text{Full}}})} \right) = 2 \log \left( \frac{L(\boldsymbol{\hat{\beta}_{\text{Full}}})} {L(\boldsymbol{\hat{\beta}_{\text{Null}}})} \right) = 2 \left( \ell(\hat{\beta}_{\text{Full}}) - \ell(\hat{\beta}_{\text{Null}})\right)
\]</span></p>
<p>where <span class="math inline">\(L\)</span> denotes a likelihood and <span class="math inline">\(\ell\)</span> denotes a log-likelihood. For a large enough sample, this test statistic has an approximate Chi-square distribution</p>
<p><span class="math display">\[
D \overset{\text{approx}}{\sim} \chi^2_{k}
\]</span></p>
<p>where <span class="math inline">\(k = p - q\)</span>, the difference in number of parameters of the two models.</p>
<p>This test, which we will call the <strong>Likelihood-Ratio Test</strong>, will be the analogue to the ANOVA <span class="math inline">\(F\)</span>-test for logistic regression. Interestingly, to perform the Likelihood-Ratio Test, we’ll actually again use the <code>anova()</code> function in <code>R</code>!.</p>
<p>The Likelihood-Ratio Test is actually a rather general test, however, here we have presented a specific application to nested logistic regression models.</p>
</div>
<div id="saheart-example" class="section level3">
<h3><span class="header-section-number">17.3.4</span> <code>SAheart</code> Example</h3>
<p>To illustrate the use of logistic regression, we will use the <code>SAheart</code> dataset from the <code>ElemStatLearn</code> package.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># install.packages(&quot;ElemStatLearn&quot;)</span>
<span class="kw">library</span>(ElemStatLearn)
<span class="kw">data</span>(<span class="st">&quot;SAheart&quot;</span>)</code></pre>
<table>
<thead>
<tr class="header">
<th align="right">sbp</th>
<th align="right">tobacco</th>
<th align="right">ldl</th>
<th align="right">adiposity</th>
<th align="left">famhist</th>
<th align="right">typea</th>
<th align="right">obesity</th>
<th align="right">alcohol</th>
<th align="right">age</th>
<th align="right">chd</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">160</td>
<td align="right">12.00</td>
<td align="right">5.73</td>
<td align="right">23.11</td>
<td align="left">Present</td>
<td align="right">49</td>
<td align="right">25.30</td>
<td align="right">97.20</td>
<td align="right">52</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td align="right">144</td>
<td align="right">0.01</td>
<td align="right">4.41</td>
<td align="right">28.61</td>
<td align="left">Absent</td>
<td align="right">55</td>
<td align="right">28.87</td>
<td align="right">2.06</td>
<td align="right">63</td>
<td align="right">1</td>
</tr>
<tr class="odd">
<td align="right">118</td>
<td align="right">0.08</td>
<td align="right">3.48</td>
<td align="right">32.28</td>
<td align="left">Present</td>
<td align="right">52</td>
<td align="right">29.14</td>
<td align="right">3.81</td>
<td align="right">46</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td align="right">170</td>
<td align="right">7.50</td>
<td align="right">6.41</td>
<td align="right">38.03</td>
<td align="left">Present</td>
<td align="right">51</td>
<td align="right">31.99</td>
<td align="right">24.26</td>
<td align="right">58</td>
<td align="right">1</td>
</tr>
<tr class="odd">
<td align="right">134</td>
<td align="right">13.60</td>
<td align="right">3.50</td>
<td align="right">27.78</td>
<td align="left">Present</td>
<td align="right">60</td>
<td align="right">25.99</td>
<td align="right">57.34</td>
<td align="right">49</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td align="right">132</td>
<td align="right">6.20</td>
<td align="right">6.47</td>
<td align="right">36.21</td>
<td align="left">Present</td>
<td align="right">62</td>
<td align="right">30.77</td>
<td align="right">14.14</td>
<td align="right">45</td>
<td align="right">0</td>
</tr>
</tbody>
</table>
<p>This data comes from a retrospective sample of males in a heart-disease high-risk region of the Western Cape, South Africa. The <code>chd</code> variable, which we will use as a response, indicates whether or not coronary heart disease is present in an individual. Note that this is coded as a numeric <code>0</code> / <code>1</code> variable. Using this as a response with <code>glm()</code> it is important to indicate <code>family = binomial</code>, otherwise ordinary linear regression will be fit. Later, we will see the use of a factor variable response, which is actually preferred, as you cannot accidentally fit ordinary linear regression.</p>
<p>The predictors are various measurements for each individual, many related to heart health. For example <code>sbp</code>, systolic blood pressure, and <code>ldl</code>, low density lipoprotein cholesterol. For full details, use <code>?SAheart</code>.</p>
<p>We’ll begin by attempting to model the probability of coronary heart disease based on low density lipoprotein cholesterol. That is, we will fit the model</p>
<p><span class="math display">\[
\log\left(\frac{P[\texttt{chd} = 1]}{1 - P[\texttt{chd} = 1]}\right) = \beta_0 + \beta_{\texttt{ldl}} \texttt{ldl}
\]</span></p>
<pre class="sourceCode r"><code class="sourceCode r">chd_mod_ldl =<span class="st"> </span><span class="kw">glm</span>(chd <span class="op">~</span><span class="st"> </span>ldl, <span class="dt">data =</span> SAheart, <span class="dt">family =</span> binomial)
<span class="kw">plot</span>(<span class="kw">jitter</span>(chd, <span class="dt">factor =</span> <span class="fl">0.1</span>) <span class="op">~</span><span class="st"> </span>ldl, <span class="dt">data =</span> SAheart, <span class="dt">pch =</span> <span class="dv">20</span>, 
     <span class="dt">ylab =</span> <span class="st">&quot;Probability of CHD&quot;</span>, <span class="dt">xlab =</span> <span class="st">&quot;Low Density Lipoprotein Cholesterol&quot;</span>)
<span class="kw">grid</span>()
<span class="kw">curve</span>(<span class="kw">predict</span>(chd_mod_ldl, <span class="kw">data.frame</span>(<span class="dt">ldl =</span> x), <span class="dt">type =</span> <span class="st">&quot;response&quot;</span>), 
      <span class="dt">add =</span> <span class="ot">TRUE</span>, <span class="dt">col =</span> <span class="st">&quot;dodgerblue&quot;</span>, <span class="dt">lty =</span> <span class="dv">2</span>)</code></pre>
<p><img src="logistic_files/figure-html/unnamed-chunk-19-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>As before, we plot the data in addition to the estimated probabilities. Note that we have “jittered” the data to make it easier to visualize, but the data do only take values <code>0</code> and <code>1</code>.</p>
<p>As we would expect, this plot indicates that as <code>ldl</code> increases, so does the probability of <code>chd</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">coef</span>(<span class="kw">summary</span>(chd_mod_ldl))</code></pre>
<pre><code>##               Estimate Std. Error   z value     Pr(&gt;|z|)
## (Intercept) -1.9686681 0.27307908 -7.209150 5.630207e-13
## ldl          0.2746613 0.05163983  5.318787 1.044615e-07</code></pre>
<p>To perform the test</p>
<p><span class="math display">\[
H_0: \beta_{\texttt{ldl}} = 0
\]</span></p>
<p>we use the <code>summary()</code> function as we have done so many times before. Like the <span class="math inline">\(t\)</span>-test for ordinary linear regression, this returns the estimate of the parameter, its standard error, the relevant test statistic (<span class="math inline">\(z\)</span>), and its p-value. Here we have an incredibly low p-value, so we reject the null hypothesis. The <code>ldl</code> variable appears to be a significant predictor.</p>
<p>When fitting logistic regression, we can use the same formula syntax as ordinary linear regression. So, to fit an additive model using all available predictors, we use:</p>
<pre class="sourceCode r"><code class="sourceCode r">chd_mod_additive =<span class="st"> </span><span class="kw">glm</span>(chd <span class="op">~</span><span class="st"> </span>., <span class="dt">data =</span> SAheart, <span class="dt">family =</span> binomial)</code></pre>
<p>We can then use the likelihood-ratio test to compare the two model. Specifically, we are testing</p>
<p><span class="math display">\[
H_0: \beta_{\texttt{sbp}} = \beta_{\texttt{tobacco}} = \beta_{\texttt{adiposity}} = \beta_{\texttt{famhist}} = \beta_{\texttt{typea}} = \beta_{\texttt{obesity}} = \beta_{\texttt{alcohol}} = \beta_{\texttt{age}} = 0
\]</span></p>
<p>We could manually calculate the test statistic,</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="dv">-2</span> <span class="op">*</span><span class="st"> </span><span class="kw">as.numeric</span>(<span class="kw">logLik</span>(chd_mod_ldl) <span class="op">-</span><span class="st"> </span><span class="kw">logLik</span>(chd_mod_additive))</code></pre>
<pre><code>## [1] 92.13879</code></pre>
<p>Or we could utilize the <code>anova()</code> function. By specifying <code>test = &quot;LRT&quot;</code>, <code>R</code> will use the likelihood-ratio test to compare the two models.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">anova</span>(chd_mod_ldl, chd_mod_additive, <span class="dt">test =</span> <span class="st">&quot;LRT&quot;</span>)</code></pre>
<pre><code>## Analysis of Deviance Table
## 
## Model 1: chd ~ ldl
## Model 2: chd ~ sbp + tobacco + ldl + adiposity + famhist + typea + obesity + 
##     alcohol + age
##   Resid. Df Resid. Dev Df Deviance  Pr(&gt;Chi)    
## 1       460     564.28                          
## 2       452     472.14  8   92.139 &lt; 2.2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<p>We see that the test statistic that we had just calculated appears in the output. The very small p-value suggests that we prefer the larger model.</p>
<p>While we prefer the additive model compared to the model with only a single predictor, do we actually need all of the predictors in the additive model? To select a subset of predictors, we can use a stepwise procedure as we did with ordinary linear regression. Recall that AIC and BIC were defined in terms of likelihoods. Here we demonstrate using AIC with a backwards selection procedure.</p>
<pre class="sourceCode r"><code class="sourceCode r">chd_mod_selected =<span class="st"> </span><span class="kw">step</span>(chd_mod_additive, <span class="dt">trace =</span> <span class="dv">0</span>)
<span class="kw">coef</span>(chd_mod_selected)</code></pre>
<pre><code>##    (Intercept)        tobacco            ldl famhistPresent          typea 
##    -6.44644451     0.08037533     0.16199164     0.90817526     0.03711521 
##            age 
##     0.05046038</code></pre>
<p>We could again compare this model to the additive models.</p>
<p><span class="math display">\[
H_0: \beta_{\texttt{sbp}} = \beta_{\texttt{adiposity}} = \beta_{\texttt{obesity}} = \beta_{\texttt{alcohol}} = 0
\]</span></p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">anova</span>(chd_mod_selected, chd_mod_additive, <span class="dt">test =</span> <span class="st">&quot;LRT&quot;</span>)</code></pre>
<pre><code>## Analysis of Deviance Table
## 
## Model 1: chd ~ tobacco + ldl + famhist + typea + age
## Model 2: chd ~ sbp + tobacco + ldl + adiposity + famhist + typea + obesity + 
##     alcohol + age
##   Resid. Df Resid. Dev Df Deviance Pr(&gt;Chi)
## 1       456     475.69                     
## 2       452     472.14  4   3.5455    0.471</code></pre>
<p>Here it seems that we would prefer the selected model.</p>
</div>
<div id="confidence-intervals-1" class="section level3">
<h3><span class="header-section-number">17.3.5</span> Confidence Intervals</h3>
<p>We can create confidence intervals for the <span class="math inline">\(\beta\)</span> parameters using the <code>confint()</code> function as we did with ordinary linear regression.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">confint</span>(chd_mod_selected, <span class="dt">level =</span> <span class="fl">0.99</span>)</code></pre>
<pre><code>## Waiting for profiling to be done...</code></pre>
<pre><code>##                       0.5 %      99.5 %
## (Intercept)    -8.941825274 -4.18278990
## tobacco         0.015704975  0.14986616
## ldl             0.022923610  0.30784590
## famhistPresent  0.330033483  1.49603366
## typea           0.006408724  0.06932612
## age             0.024847330  0.07764277</code></pre>
<p>Note that we could create intervals by rearranging the results of the Wald test to obtain the Wald confidence interval. This would be given by</p>
<p><span class="math display">\[
\hat{\beta}_j \pm z_{\alpha/2} \cdot \text{SE}[\hat{\beta}_j].
\]</span></p>
<p>However, <code>R</code> is using a slightly different approach based on a concept called the profile likelihood. (The details of which we will omit.) Ultimately the intervals reported will be similar, but the method used by <code>R</code> is more common in practice, probably at least partially because it is the default approach in <code>R</code>. Check to see how intervals using the formula above compare to those from the output of <code>confint()</code>. (Or, note that using <code>confint.default()</code> will return the results of calculating the Wald confidence interval.)</p>
</div>
<div id="confidence-intervals-for-mean-response-1" class="section level3">
<h3><span class="header-section-number">17.3.6</span> Confidence Intervals for Mean Response</h3>
<p>Confidence intervals for the mean response require some additional thought. With a “large enough” sample, we have</p>
<p><span class="math display">\[
\frac{\hat{\eta}({\bf x}) - \eta({\bf x})}{\text{SE}[\hat{\eta}({\bf x})]} \overset{\text{approx}}{\sim} N(0, 1)
\]</span></p>
<p>Then we can create an approximate <span class="math inline">\((1 - \alpha)\%\)</span> confidence intervals for <span class="math inline">\(\eta({\bf x})\)</span> using</p>
<p><span class="math display">\[
\hat{\eta}({\bf x}) \pm z_{\alpha/2} \cdot \text{SE}[\hat{\eta}({\bf x})]] 
\]</span></p>
<p>where <span class="math inline">\(z_{\alpha/2}\)</span> is the critical value such that <span class="math inline">\(P(Z &gt; z_{\alpha/2}) = \alpha/2\)</span>.</p>
<p>This isn’t a particularly interesting interval. Instead, what we really want is an interval for the mean response, <span class="math inline">\(p({\bf x})\)</span>. To obtain an interval for <span class="math inline">\(p({\bf x})\)</span>, we simply apply the inverse logit transform to the endpoints of the interval for <span class="math inline">\(\eta.\)</span></p>
<p><span class="math display">\[
\left(\text{logit}^{-1}(\hat{\eta}({\bf x}) - z_{\alpha/2} \cdot \text{SE}[\hat{\eta}({\bf x})] ), \ \text{logit}^{-1}(\hat{\eta}({\bf x}) + z_{\alpha/2} \cdot \text{SE}[\hat{\eta}({\bf x})])\right)
\]</span></p>
<p>To demonstrate creating these intervals, we’ll consider a new observation.</p>
<pre class="sourceCode r"><code class="sourceCode r">new_obs =<span class="st"> </span><span class="kw">data.frame</span>(
  <span class="dt">sbp =</span> <span class="fl">148.0</span>,
  <span class="dt">tobacco =</span> <span class="dv">5</span>,
  <span class="dt">ldl =</span> <span class="dv">12</span>,
  <span class="dt">adiposity =</span> <span class="fl">31.23</span>,
  <span class="dt">famhist =</span> <span class="st">&quot;Present&quot;</span>,
  <span class="dt">typea =</span> <span class="dv">47</span>,
  <span class="dt">obesity =</span> <span class="fl">28.50</span>,
  <span class="dt">alcohol =</span> <span class="fl">23.89</span>,
  <span class="dt">age =</span> <span class="dv">60</span>
)</code></pre>
<p>Fist, we’ll use the <code>predict()</code> function to obtain <span class="math inline">\(\hat{\eta}({\bf x})\)</span> for this observation.</p>
<pre class="sourceCode r"><code class="sourceCode r">eta_hat =<span class="st"> </span><span class="kw">predict</span>(chd_mod_selected, new_obs, <span class="dt">se.fit =</span> <span class="ot">TRUE</span>, <span class="dt">type =</span> <span class="st">&quot;link&quot;</span>)
eta_hat</code></pre>
<pre><code>## $fit
##        1 
## 1.579545 
## 
## $se.fit
## [1] 0.4114796
## 
## $residual.scale
## [1] 1</code></pre>
<p>By setting <code>se.fit = TRUE</code>, <code>R</code> also computes <span class="math inline">\(\text{SE}[\hat{\eta}({\bf x})]\)</span>. Note that we used <code>type = &quot;link&quot;</code>, but this is actually a default value. We added it here to stress that the output from <code>predict()</code> will be the value of the link function.</p>
<pre class="sourceCode r"><code class="sourceCode r">z_crit =<span class="st"> </span><span class="kw">round</span>(<span class="kw">qnorm</span>(<span class="fl">0.975</span>), <span class="dv">2</span>)
<span class="kw">round</span>(z_crit, <span class="dv">2</span>)</code></pre>
<pre><code>## [1] 1.96</code></pre>
<p>After obtaining the correct critical value, we can easily create a <span class="math inline">\(95\%\)</span> confidence interval for <span class="math inline">\(\eta({\bf x})\)</span>.</p>
<pre class="sourceCode r"><code class="sourceCode r">eta_hat<span class="op">$</span>fit <span class="op">+</span><span class="st"> </span><span class="kw">c</span>(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>) <span class="op">*</span><span class="st"> </span>z_crit <span class="op">*</span><span class="st"> </span>eta_hat<span class="op">$</span>se.fit</code></pre>
<pre><code>## [1] 0.773045 2.386045</code></pre>
<p>Now we simply need to apply the correct transformation to make this a confidence interval for <span class="math inline">\(p({\bf x})\)</span>, the probability of coronary heart disease for this observation. Note that the <code>boot</code> package contains functions <code>logit()</code> and <code>inv.logit()</code> which are the logit and inverse logit transformations, respectively.</p>
<pre class="sourceCode r"><code class="sourceCode r">boot<span class="op">::</span><span class="kw">inv.logit</span>(eta_hat<span class="op">$</span>fit <span class="op">+</span><span class="st"> </span><span class="kw">c</span>(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>) <span class="op">*</span><span class="st"> </span>z_crit <span class="op">*</span><span class="st"> </span>eta_hat<span class="op">$</span>se.fit)</code></pre>
<pre><code>## [1] 0.6841792 0.9157570</code></pre>
<p>Notice, as we would expect, the bounds of this interval are both between 0 and 1. Also, since both bounds of the interval for <span class="math inline">\(\eta({\bf x})\)</span> are positive, both bounds of the interval for <span class="math inline">\(p({\bf x})\)</span> are greater than 0.5.</p>
</div>
<div id="formula-syntax" class="section level3">
<h3><span class="header-section-number">17.3.7</span> Formula Syntax</h3>
<p>Without really thinking about it, we’ve been using our previous knowledge of <code>R</code>’s model formula syntax to fit logistic regression.</p>
<div id="interactions-1" class="section level4">
<h4><span class="header-section-number">17.3.7.1</span> Interactions</h4>
<p>Let’s add an interaction between LDL and family history for the model we selected.</p>
<pre class="sourceCode r"><code class="sourceCode r">chd_mod_interaction =<span class="st"> </span><span class="kw">glm</span>(chd <span class="op">~</span><span class="st"> </span>alcohol <span class="op">+</span><span class="st"> </span>ldl <span class="op">+</span><span class="st"> </span>famhist <span class="op">+</span><span class="st"> </span>typea <span class="op">+</span><span class="st"> </span>age <span class="op">+</span><span class="st"> </span>ldl<span class="op">:</span>famhist, 
                          <span class="dt">data =</span> SAheart, <span class="dt">family =</span> binomial)
<span class="kw">summary</span>(chd_mod_interaction)</code></pre>
<pre><code>## 
## Call:
## glm(formula = chd ~ alcohol + ldl + famhist + typea + age + ldl:famhist, 
##     family = binomial, data = SAheart)
## 
## Deviance Residuals: 
##     Min       1Q   Median       3Q      Max  
## -1.9082  -0.8308  -0.4550   0.9286   2.5152  
## 
## Coefficients:
##                     Estimate Std. Error z value Pr(&gt;|z|)    
## (Intercept)        -6.043472   0.937186  -6.449 1.13e-10 ***
## alcohol             0.003800   0.004332   0.877  0.38033    
## ldl                 0.035593   0.071448   0.498  0.61837    
## famhistPresent     -0.733836   0.618131  -1.187  0.23515    
## typea               0.036253   0.012172   2.978  0.00290 ** 
## age                 0.062416   0.009723   6.419 1.37e-10 ***
## ldl:famhistPresent  0.314311   0.114922   2.735  0.00624 ** 
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## (Dispersion parameter for binomial family taken to be 1)
## 
##     Null deviance: 596.11  on 461  degrees of freedom
## Residual deviance: 477.46  on 455  degrees of freedom
## AIC: 491.46
## 
## Number of Fisher Scoring iterations: 5</code></pre>
<p>Based on the <span class="math inline">\(z\)</span>-test seen in the above summary, this interaction is significant. The effect of LDL on the probability of CHD is different depending on family history.</p>
</div>
<div id="polynomial-terms" class="section level4">
<h4><span class="header-section-number">17.3.7.2</span> Polynomial Terms</h4>
<p>Let’s take the previous model, and now add a polynomial term.</p>
<pre class="sourceCode r"><code class="sourceCode r">chd_mod_int_quad =<span class="st"> </span><span class="kw">glm</span>(chd <span class="op">~</span><span class="st"> </span>alcohol <span class="op">+</span><span class="st"> </span>ldl <span class="op">+</span><span class="st"> </span>famhist <span class="op">+</span><span class="st"> </span>typea <span class="op">+</span><span class="st"> </span>age <span class="op">+</span><span class="st"> </span>ldl<span class="op">:</span>famhist <span class="op">+</span><span class="st"> </span><span class="kw">I</span>(ldl<span class="op">^</span><span class="dv">2</span>),
                       <span class="dt">data =</span> SAheart, <span class="dt">family =</span> binomial)
<span class="kw">summary</span>(chd_mod_int_quad)</code></pre>
<pre><code>## 
## Call:
## glm(formula = chd ~ alcohol + ldl + famhist + typea + age + ldl:famhist + 
##     I(ldl^2), family = binomial, data = SAheart)
## 
## Deviance Residuals: 
##     Min       1Q   Median       3Q      Max  
## -1.8953  -0.8311  -0.4556   0.9276   2.5204  
## 
## Coefficients:
##                     Estimate Std. Error z value Pr(&gt;|z|)    
## (Intercept)        -6.096747   1.065952  -5.720 1.07e-08 ***
## alcohol             0.003842   0.004350   0.883  0.37716    
## ldl                 0.056876   0.214420   0.265  0.79081    
## famhistPresent     -0.723769   0.625167  -1.158  0.24698    
## typea               0.036248   0.012171   2.978  0.00290 ** 
## age                 0.062299   0.009788   6.365 1.95e-10 ***
## I(ldl^2)           -0.001587   0.015076  -0.105  0.91617    
## ldl:famhistPresent  0.311615   0.117559   2.651  0.00803 ** 
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## (Dispersion parameter for binomial family taken to be 1)
## 
##     Null deviance: 596.11  on 461  degrees of freedom
## Residual deviance: 477.45  on 454  degrees of freedom
## AIC: 493.45
## 
## Number of Fisher Scoring iterations: 5</code></pre>
<p>Unsurprisingly, since this additional transformed variable wasn’t intelligently chosen, it is not significant. However, this does allow us to stress the fact that the syntax notation that we had been using with <code>lm()</code> works basically exactly the same for <code>glm()</code>, however now we understand that this is specifying the linear combination of predictions, <span class="math inline">\(\eta({\bf x})\)</span>.</p>
<p>That is, the above fits the model</p>
<p><span class="math display">\[
\log\left(\frac{p({\bf x})}{1 - p({\bf x})}\right) = 
\beta_0 +
\beta_{1}x_{\texttt{alcohol}} +
\beta_{2}x_{\texttt{ldl}} +
\beta_{3}x_{\texttt{famhist}} +
\beta_{4}x_{\texttt{typea}} +
\beta_{5}x_{\texttt{age}} +
\beta_{6}x_{\texttt{ldl}}x_{\texttt{famhist}} +
\beta_{7}x_{\texttt{ldl}}^2
\]</span></p>
<p>You may have realized this before we actually explicitly wrote it down!</p>
</div>
</div>
<div id="deviance" class="section level3">
<h3><span class="header-section-number">17.3.8</span> Deviance</h3>
<p>You have probably noticed that the output from <code>summary()</code> is also very similar to that of ordinary linear regression. One difference, is the “deviance” being reported. The <code>Null deviance</code> is the deviance for the null model, that is, a model with no predictors. The <code>Residual deviance</code> is the deviance for the mode that was fit.</p>
<p><a href="https://en.wikipedia.org/wiki/Deviance_(statistics)" target="_blank"><strong>Deviance</strong></a> compares the model to a saturated model. (Without repeated observations, a saturated model is a model that fits perfectly, using a parameter for each observation.) Essentially, deviance is a generalized <em>residual sum of squared</em> for GLMs. Like RSS, deviance decreased as the model complexity increases.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">deviance</span>(chd_mod_ldl)</code></pre>
<pre><code>## [1] 564.2788</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">deviance</span>(chd_mod_selected)</code></pre>
<pre><code>## [1] 475.6856</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">deviance</span>(chd_mod_additive)</code></pre>
<pre><code>## [1] 472.14</code></pre>
<p>Note that these are nested, and we see that deviance does decrease as the model size becomes larger. So while a lower deviance is better, if the model becomes too big, it may be overfitting. Note that <code>R</code> also outputs AIC in the summary, which will penalize according to model size, to prevent overfitting.</p>
</div>
</div>
<div id="classification" class="section level2">
<h2><span class="header-section-number">17.4</span> Classification</h2>
<p>So far we’ve mostly used logistic regression to estimate class probabilities. The somewhat obvious next step is to use these probabilities to make “predictions,” which in this context, we would call <strong>classifications</strong>. Based on the values of the predictors, should an observation be classified as <span class="math inline">\(Y = 1\)</span> or as <span class="math inline">\(Y = 0\)</span>?</p>
<p>Suppose we didn’t need to estimate probabilities from data, and instead, we actually knew both</p>
<p><span class="math display">\[
p({\bf x}) = P[Y = 1 \mid {\bf X} = {\bf x}]
\]</span></p>
<p>and</p>
<p><span class="math display">\[
1 - p({\bf x}) = P[Y = 0 \mid {\bf X} = {\bf x}].
\]</span></p>
<p>With this information, classifying observations based on the values of the predictors is actually extremely easy. Simply classify an observation to the class (<span class="math inline">\(0\)</span> or <span class="math inline">\(1\)</span>) with the larger probability. In general, this result is called the <strong>Bayes Classifier</strong>,</p>
<p><span class="math display">\[
C^B({\bf x}) = \underset{k}{\mathrm{argmax}} \ P[Y = k \mid {\bf X = x}].
\]</span></p>
<p>For a binary response, that is,</p>
<p><span class="math display">\[
\hat{C}(\bf x) = 
\begin{cases} 
      1 &amp; p({\bf x}) &gt; 0.5 \\
      0 &amp; p({\bf x}) \leq 0.5 
\end{cases}
\]</span></p>
<p>Simply put, the Bayes classifier (not to be confused with the Naive Bayes Classifier) minimizes the probability of misclassification by classifying each observation to the class with the highest probability. Unfortunately, in practice, we won’t know the necessary probabilities to directly use the Bayes classifier. Instead we’ll have to use estimated probabilities. So to create a classifier that seeks to minimize misclassifications, we would use,</p>
<p><span class="math display">\[
\hat{C}({\bf x}) = \underset{k}{\mathrm{argmax}} \ \hat{P}[Y = k \mid {\bf X = x}].
\]</span></p>
<p>In the case of a binary response since <span class="math inline">\(\hat{p}({\bf x}) = 1 - \hat{p}({\bf x})\)</span>, this becomes</p>
<p><span class="math display">\[
\hat{C}(\bf x) = 
\begin{cases} 
      1 &amp; \hat{p}({\bf x}) &gt; 0.5 \\
      0 &amp; \hat{p}({\bf x}) \leq 0.5 
\end{cases}
\]</span></p>
<p>Using this simple classification rule, we can turn logistic regression into a classifier. To use logistic regression for classification, we first use logistic regression to obtain estimated probabilities, <span class="math inline">\(\hat{p}({\bf x})\)</span>, then use these in conjunction with the above classification rule.</p>
<p>Logistic regression is just one of many ways that these probabilities could be estimated. In a course completely focused on machine learning, you’ll learn many additional ways to do this, as well as methods to directly make classifications without needing to first estimate probabilities. But since we had already introduced logistic regression, it makes sense to discuss it in the context of classification.</p>
<div id="spam-example" class="section level3">
<h3><span class="header-section-number">17.4.1</span> <code>spam</code> Example</h3>
<p>To illustrate the use of logistic regression as a classifier, we will use the <code>spam</code> dataset from the <code>kernlab</code> package.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># install.packages(&quot;kernlab&quot;)</span>
<span class="kw">library</span>(kernlab)
<span class="kw">data</span>(<span class="st">&quot;spam&quot;</span>)
tibble<span class="op">::</span><span class="kw">as.tibble</span>(spam)</code></pre>
<pre><code>## # A tibble: 4,601 x 58
##     make address   all num3d   our  over remove internet order  mail
##  * &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1  0       0.64  0.64     0  0.32  0      0        0     0     0   
##  2  0.21    0.28  0.5      0  0.14  0.28   0.21     0.07  0     0.94
##  3  0.06    0     0.71     0  1.23  0.19   0.19     0.12  0.64  0.25
##  4  0       0     0        0  0.63  0      0.31     0.63  0.31  0.63
##  5  0       0     0        0  0.63  0      0.31     0.63  0.31  0.63
##  6  0       0     0        0  1.85  0      0        1.85  0     0   
##  7  0       0     0        0  1.92  0      0        0     0     0.64
##  8  0       0     0        0  1.88  0      0        1.88  0     0   
##  9  0.15    0     0.46     0  0.61  0      0.3      0     0.92  0.76
## 10  0.06    0.12  0.77     0  0.19  0.32   0.38     0     0.06  0   
## # ... with 4,591 more rows, and 48 more variables: receive &lt;dbl&gt;,
## #   will &lt;dbl&gt;, people &lt;dbl&gt;, report &lt;dbl&gt;, addresses &lt;dbl&gt;, free &lt;dbl&gt;,
## #   business &lt;dbl&gt;, email &lt;dbl&gt;, you &lt;dbl&gt;, credit &lt;dbl&gt;, your &lt;dbl&gt;,
## #   font &lt;dbl&gt;, num000 &lt;dbl&gt;, money &lt;dbl&gt;, hp &lt;dbl&gt;, hpl &lt;dbl&gt;,
## #   george &lt;dbl&gt;, num650 &lt;dbl&gt;, lab &lt;dbl&gt;, labs &lt;dbl&gt;, telnet &lt;dbl&gt;,
## #   num857 &lt;dbl&gt;, data &lt;dbl&gt;, num415 &lt;dbl&gt;, num85 &lt;dbl&gt;, technology &lt;dbl&gt;,
## #   num1999 &lt;dbl&gt;, parts &lt;dbl&gt;, pm &lt;dbl&gt;, direct &lt;dbl&gt;, cs &lt;dbl&gt;,
## #   meeting &lt;dbl&gt;, original &lt;dbl&gt;, project &lt;dbl&gt;, re &lt;dbl&gt;, edu &lt;dbl&gt;,
## #   table &lt;dbl&gt;, conference &lt;dbl&gt;, charSemicolon &lt;dbl&gt;,
## #   charRoundbracket &lt;dbl&gt;, charSquarebracket &lt;dbl&gt;,
## #   charExclamation &lt;dbl&gt;, charDollar &lt;dbl&gt;, charHash &lt;dbl&gt;,
## #   capitalAve &lt;dbl&gt;, capitalLong &lt;dbl&gt;, capitalTotal &lt;dbl&gt;, type &lt;fct&gt;</code></pre>
<p>This dataset, created in the late 1990s at Hewlett-Packard Labs, contains 4601 emails, of which 1813 are considered spam. The remaining are not spam. (Which for simplicity, we might call, ham.) Additional details can be obtained by using <code>?spam</code> of by visiting the <a href="https://archive.ics.uci.edu/ml/datasets/spambase" target="_blank">UCI Machine Learning Repository</a>.</p>
<p>The response variable, <code>type</code>, is a <strong>factor</strong> with levels that label each email as <code>spam</code> or <code>nonspam</code>. When fitting models, <code>nonspam</code> will be the reference level, <span class="math inline">\(Y = 0\)</span>, as it comes first alphabetically.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">is.factor</span>(spam<span class="op">$</span>type)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">levels</span>(spam<span class="op">$</span>type)</code></pre>
<pre><code>## [1] &quot;nonspam&quot; &quot;spam&quot;</code></pre>
<p>Many of the predictors (often called features in machine learning) are engineered based on the emails. For example, <code>charDollar</code> is the number of times an email contains the <code>$</code> character. Some variables are highly specific to this dataset, for example <code>george</code> and <code>num650</code>. (The name and area code for one of the researchers whose emails were used.) We should keep in mind that this dataset was created based on emails send to academic type researcher in the 1990s. Any results we derive probably won’t generalize to modern emails for the general public.</p>
<p>To get started, we’ll first test-train split the data.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">42</span>)
<span class="co"># spam_idx = sample(nrow(spam), round(nrow(spam) / 2))</span>
spam_idx =<span class="st"> </span><span class="kw">sample</span>(<span class="kw">nrow</span>(spam), <span class="dv">1000</span>)
spam_trn =<span class="st"> </span>spam[spam_idx, ]
spam_tst =<span class="st"> </span>spam[<span class="op">-</span>spam_idx, ]</code></pre>
<p>We’ve used a somewhat small train set relative to the total size of the dataset. In practice it should likely be larger, but this is simply to keep training time low for illustration and rendering of this document.</p>
<pre class="sourceCode r"><code class="sourceCode r">fit_caps =<span class="st"> </span><span class="kw">glm</span>(type <span class="op">~</span><span class="st"> </span>capitalTotal, 
               <span class="dt">data =</span> spam_trn, <span class="dt">family =</span> binomial)
fit_selected =<span class="st"> </span><span class="kw">glm</span>(type <span class="op">~</span><span class="st"> </span>edu <span class="op">+</span><span class="st"> </span>money <span class="op">+</span><span class="st"> </span>capitalTotal <span class="op">+</span><span class="st"> </span>charDollar, 
                   <span class="dt">data =</span> spam_trn, <span class="dt">family =</span> binomial)
fit_additive =<span class="st"> </span><span class="kw">glm</span>(type <span class="op">~</span><span class="st"> </span>., 
                   <span class="dt">data =</span> spam_trn, <span class="dt">family =</span> binomial)
fit_over =<span class="st"> </span><span class="kw">glm</span>(type <span class="op">~</span><span class="st"> </span>capitalTotal <span class="op">*</span><span class="st"> </span>(.), 
               <span class="dt">data =</span> spam_trn, <span class="dt">family =</span> binomial, <span class="dt">maxit =</span> <span class="dv">50</span>)</code></pre>
<p>We’ll fit four logistic regressions, each more complex than the previous. Note that we’re suppressing two warnings. The first we briefly mentioned previously.</p>
<pre><code>## Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred</code></pre>
<p>Note that, when we receive this warning, we should be highly suspicious of the parameter estimates.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">coef</span>(fit_selected)</code></pre>
<pre><code>##   (Intercept)           edu         money  capitalTotal    charDollar 
## -1.1248423316 -3.4811734345  1.0303968430  0.0009187823 12.3988576908</code></pre>
<p>However, the model can still be used to create a classifier, and we will evaluate that classifier on its own merits.</p>
<p>We also, “suppressed” the warning:</p>
<pre><code>## Warning: glm.fit: algorithm did not converge</code></pre>
<p>In reality, we didn’t actually suppress it, but instead changed <code>maxit</code> to <code>50</code>, when fitting the model <code>fit_over</code>. This was enough additional iterations to allow the iteratively reweighted least squares algorithm to converge when fitting the model.</p>
</div>
<div id="evaluating-classifiers" class="section level3">
<h3><span class="header-section-number">17.4.2</span> Evaluating Classifiers</h3>
<p>The metric we’ll be most interested in for evaluating the overall performance of a classifier is the <strong>misclassification rate</strong>. (Sometimes, instead accuracy is reported, which is instead the proportion of correction classifications, so both metrics serve the same purpose.)</p>
<p><span class="math display">\[
\text{Misclass}(\hat{C}, \text{Data}) = \frac{1}{n}\sum_{i = 1}^{n}I(y_i \neq \hat{C}({\bf x_i}))
\]</span></p>
<p><span class="math display">\[
I(y_i \neq \hat{C}({\bf x_i})) = 
\begin{cases} 
  0 &amp; y_i = \hat{C}({\bf x_i}) \\
  1 &amp; y_i \neq \hat{C}({\bf x_i}) \\
\end{cases}
\]</span></p>
<p>When using this metric on the training data, it will have the same issues as RSS did for ordinary linear regression, that is, it will only go down.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># training misclassification rate</span>
<span class="kw">mean</span>(<span class="kw">ifelse</span>(<span class="kw">predict</span>(fit_caps) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>, <span class="st">&quot;spam&quot;</span>, <span class="st">&quot;nonspam&quot;</span>) <span class="op">!=</span><span class="st"> </span>spam_trn<span class="op">$</span>type)</code></pre>
<pre><code>## [1] 0.342</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">mean</span>(<span class="kw">ifelse</span>(<span class="kw">predict</span>(fit_selected) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>, <span class="st">&quot;spam&quot;</span>, <span class="st">&quot;nonspam&quot;</span>) <span class="op">!=</span><span class="st"> </span>spam_trn<span class="op">$</span>type)</code></pre>
<pre><code>## [1] 0.212</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">mean</span>(<span class="kw">ifelse</span>(<span class="kw">predict</span>(fit_additive) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>, <span class="st">&quot;spam&quot;</span>, <span class="st">&quot;nonspam&quot;</span>) <span class="op">!=</span><span class="st"> </span>spam_trn<span class="op">$</span>type)</code></pre>
<pre><code>## [1] 0.064</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">mean</span>(<span class="kw">ifelse</span>(<span class="kw">predict</span>(fit_over) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>, <span class="st">&quot;spam&quot;</span>, <span class="st">&quot;nonspam&quot;</span>) <span class="op">!=</span><span class="st"> </span>spam_trn<span class="op">$</span>type)</code></pre>
<pre><code>## [1] 0.063</code></pre>
<p>Because of this, training data isn’t useful for evaluating, as it would suggest that we should always use the largest possible model, when in reality, that model is likely overfitting. Recall, a model that is too complex will overfit. A model that is too simple will underfit. (We’re looking for something in the middle.)</p>
<p>To overcome this, we’ll use cross-validation as we did with ordinary linear regression, but this time we’ll cross-validate the misclassification rate. To do so, we’ll use the <code>cv.glm()</code> function from the <code>boot</code> library. It takes arguments for the data (in this case training), a model fit via <code>glm()</code>, and <code>K</code>, the number of folds. See <code>?cv.glm</code> for details.</p>
<p>Previously, for cross-validating RMSE in ordinary linear regression, we used LOOCV. We certainly could do that here. However, with logistic regression, we no longer have the clever trick that would allow use to obtain a LOOCV metric without needing to fit the model <span class="math inline">\(n\)</span> times. So instead, we’ll use 5-fold cross-validation. (5 and 10 fold are the most common in practice.) Instead of leaving a single observation out repeatedly, we’ll leave out a fifth of the data.</p>
<p>Essentially we’ll repeat the following process 5 times:</p>
<ul>
<li>Randomly set aside a fifth of the data (each observation will only be held-out once)</li>
<li>Train model on remaining data</li>
<li>Evaluate misclassification rate on held-out data</li>
</ul>
<p>The 5-fold cross-validated misclassification rate will be the average of these misclassification rates. By only needing to refit the model 5 times, instead of <span class="math inline">\(n\)</span> times, we will save a lot of computation time.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(boot)
<span class="kw">set.seed</span>(<span class="dv">1</span>)
<span class="kw">cv.glm</span>(spam_trn, fit_caps, <span class="dt">K =</span> <span class="dv">5</span>)<span class="op">$</span>delta[<span class="dv">1</span>]</code></pre>
<pre><code>## [1] 0.2138392</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cv.glm</span>(spam_trn, fit_selected, <span class="dt">K =</span> <span class="dv">5</span>)<span class="op">$</span>delta[<span class="dv">1</span>]</code></pre>
<pre><code>## [1] 0.1522741</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cv.glm</span>(spam_trn, fit_additive, <span class="dt">K =</span> <span class="dv">5</span>)<span class="op">$</span>delta[<span class="dv">1</span>]</code></pre>
<pre><code>## [1] 0.07346089</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cv.glm</span>(spam_trn, fit_over, <span class="dt">K =</span> <span class="dv">5</span>)<span class="op">$</span>delta[<span class="dv">1</span>]</code></pre>
<pre><code>## [1] 0.11</code></pre>
<p>Note that we’re suppressing warnings again here. (Now there would be a lot more, since were fitting a total of 20 models.)</p>
<p>Based on these results, <code>fit_caps</code> and <code>fit_selected</code> are underfitting relative to <code>fit_additive</code>. Similarly, <code>fit_over</code> is overfitting relative to <code>fit_additive</code>. Thus, based on these results, we prefer the classifier created based on the logistic regression fit and stored in <code>fit_additive</code>.</p>
<p>Going forward, to evaluate and report on the efficacy of this classifier, we’ll use the test dataset. We’re going to take the position that the test data set should <strong>never</strong> be used in training, which is why we used cross-validation within the training dataset to select a model. Even though cross-validation uses hold-out sets to generate metrics, at some point all of the data is used for training.</p>
<p>To quickly summarize how well this classifier works, we’ll create a confusion matrix.</p>
<div class="figure">
<img src="images/confusion.png" alt="Confusion Matrix" />
<p class="caption">Confusion Matrix</p>
</div>
<p>It further breaks down the classification errors into false positives and false negatives.</p>
<pre class="sourceCode r"><code class="sourceCode r">make_conf_mat =<span class="st"> </span><span class="cf">function</span>(predicted, actual) {
  <span class="kw">table</span>(<span class="dt">predicted =</span> predicted, <span class="dt">actual =</span> actual)
}</code></pre>
<p>Let’s explicitly store the predicted values of our classifier on the test dataset.</p>
<pre class="sourceCode r"><code class="sourceCode r">spam_tst_pred =<span class="st"> </span><span class="kw">ifelse</span>(<span class="kw">predict</span>(fit_additive, spam_tst) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>, 
                       <span class="st">&quot;spam&quot;</span>, 
                       <span class="st">&quot;nonspam&quot;</span>)
spam_tst_pred =<span class="st"> </span><span class="kw">ifelse</span>(<span class="kw">predict</span>(fit_additive, spam_tst, <span class="dt">type =</span> <span class="st">&quot;response&quot;</span>) <span class="op">&gt;</span><span class="st"> </span><span class="fl">0.5</span>, 
                       <span class="st">&quot;spam&quot;</span>, 
                       <span class="st">&quot;nonspam&quot;</span>)</code></pre>
<p>The previous two lines of code produce the same output, that is the same predictions, since</p>
<p><span class="math display">\[
\eta({\bf x}) = 0 \iff p({\bf x}) = 0.5
\]</span>
Now we’ll use these predictions to create a confusion matrix.</p>
<pre class="sourceCode r"><code class="sourceCode r">(<span class="dt">conf_mat_50 =</span> <span class="kw">make_conf_mat</span>(<span class="dt">predicted =</span> spam_tst_pred, <span class="dt">actual =</span> spam_tst<span class="op">$</span>type))</code></pre>
<pre><code>##          actual
## predicted nonspam spam
##   nonspam    2050  161
##   spam        137 1253</code></pre>
<p><span class="math display">\[
\text{Prev} = \frac{\text{P}}{\text{Total Obs}}= \frac{\text{TP + FN}}{\text{Total Obs}}
\]</span></p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">table</span>(spam_tst<span class="op">$</span>type) <span class="op">/</span><span class="st"> </span><span class="kw">nrow</span>(spam_tst)</code></pre>
<pre><code>## 
##   nonspam      spam 
## 0.6073313 0.3926687</code></pre>
<p>First, note that to be a reasonable classifier, it needs to outperform the obvious classifier of simply classifying all observations to the majority class. In this case, classifying everything as non-spam for a test misclassification rate of 0.3926687</p>
<p>Next, we can see that using the classifier create from <code>fit_additive</code>, only a total of <span class="math inline">\(137 + 161 = 298\)</span> from the total of 3601 email in the test set are misclassified. Overall, the accuracy in the test set it</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">mean</span>(spam_tst_pred <span class="op">==</span><span class="st"> </span>spam_tst<span class="op">$</span>type)</code></pre>
<pre><code>## [1] 0.9172452</code></pre>
<p>In other words, the test misclassification is</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">mean</span>(spam_tst_pred <span class="op">!=</span><span class="st"> </span>spam_tst<span class="op">$</span>type)</code></pre>
<pre><code>## [1] 0.08275479</code></pre>
<p>This seems like a decent classifier…</p>
<p>However, are all errors created equal? In this case, absolutely note. The 137 non-spam emails that were marked as spam (false positives) are a problem. We can’t allow important information, say, a job offer, miss our inbox and get sent to the spam folder. On the other hand, the 161 spam email that would make it to an inbox (false negatives) are easily dealt with, just delete them.</p>
<p>Instead of simply evaluating a classifier based on its misclassification rate (or accuracy), we’ll define two additional metrics, sensitivity and specificity. Note that this are simply two of many more metrics that can be considered. The <a href="https://en.wikipedia.org/wiki/Sensitivity_and_specificity" target="_blank">Wikipedia page for sensitivity and specificity</a> details a large number of metrics that can be derived form a confusion matrix.</p>
<p><strong>Sensitivity</strong> is essentially the true positive rate. So when sensitivity is high, the number of false negatives is low.</p>
<p><span class="math display">\[
\text{Sens} = \text{True Positive Rate} = \frac{\text{TP}}{\text{P}} = \frac{\text{TP}}{\text{TP + FN}}
\]</span></p>
<p>Here we have an <code>R</code> function to calculate the sensitivity based on the confusion matrix. Note that this function is good for illustrative purposes, but is easily broken. (Think about what happens if there are no “positives” predicted.)</p>
<pre class="sourceCode r"><code class="sourceCode r">get_sens =<span class="st"> </span><span class="cf">function</span>(conf_mat) {
  conf_mat[<span class="dv">2</span>, <span class="dv">2</span>] <span class="op">/</span><span class="st"> </span><span class="kw">sum</span>(conf_mat[, <span class="dv">2</span>])
}</code></pre>
<p><strong>Specificity</strong> is essentially the true negative rate. So when specificity is high, the number of false positives is low.</p>
<p><span class="math display">\[
\text{Spec} = \text{True Negative Rate} = \frac{\text{TN}}{\text{N}} = \frac{\text{TN}}{\text{TN + FP}}
\]</span></p>
<pre class="sourceCode r"><code class="sourceCode r">get_spec =<span class="st">  </span><span class="cf">function</span>(conf_mat) {
  conf_mat[<span class="dv">1</span>, <span class="dv">1</span>] <span class="op">/</span><span class="st"> </span><span class="kw">sum</span>(conf_mat[, <span class="dv">1</span>])
}</code></pre>
<p>We calculate both based on the confusion matrix we had created for our classifier.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">get_sens</span>(conf_mat_<span class="dv">50</span>)</code></pre>
<pre><code>## [1] 0.8861386</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">get_spec</span>(conf_mat_<span class="dv">50</span>)</code></pre>
<pre><code>## [1] 0.9373571</code></pre>
<p>Recall that we had created this classifier using a probability of <span class="math inline">\(0.5\)</span> as a “cutoff” for how observations should be classified. Now we’ll modify this cutoff. We’ll see that by modifying the cutoff, <span class="math inline">\(c\)</span>, we can improve sensitivity or specificity at the expense of the overall accuracy (misclassification rate).</p>
<p><span class="math display">\[
\hat{C}(\bf x) = 
\begin{cases} 
      1 &amp; \hat{p}({\bf x}) &gt; c \\
      0 &amp; \hat{p}({\bf x}) \leq c 
\end{cases}
\]</span></p>
<p>Additionally, if we change the cutoff to improve sensitivity, we’ll decrease specificity, and vice versa.</p>
<p>First let’s see what happens when we lower the cutoff from <span class="math inline">\(0.5\)</span> to <span class="math inline">\(0.1\)</span> to create a new classifier, and thus new predictions.</p>
<pre class="sourceCode r"><code class="sourceCode r">spam_tst_pred_<span class="dv">10</span> =<span class="st"> </span><span class="kw">ifelse</span>(<span class="kw">predict</span>(fit_additive, spam_tst, <span class="dt">type =</span> <span class="st">&quot;response&quot;</span>) <span class="op">&gt;</span><span class="st"> </span><span class="fl">0.1</span>, 
                          <span class="st">&quot;spam&quot;</span>, 
                          <span class="st">&quot;nonspam&quot;</span>)</code></pre>
<p>This is essentially <em>decreasing</em> the threshold for an email to be labeled as spam, so far <em>more</em> emails will be labeled as spam. We see that in the following confusion matrix.</p>
<pre class="sourceCode r"><code class="sourceCode r">(<span class="dt">conf_mat_10 =</span> <span class="kw">make_conf_mat</span>(<span class="dt">predicted =</span> spam_tst_pred_<span class="dv">10</span>, <span class="dt">actual =</span> spam_tst<span class="op">$</span>type))</code></pre>
<pre><code>##          actual
## predicted nonspam spam
##   nonspam    1654   31
##   spam        533 1383</code></pre>
<p>Unfortunately, while this does greatly reduce false negatives, false positives have almost quadrupled. We see this reflected in the sensitivity and specificity.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">get_sens</span>(conf_mat_<span class="dv">10</span>)</code></pre>
<pre><code>## [1] 0.9780764</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">get_spec</span>(conf_mat_<span class="dv">10</span>)</code></pre>
<pre><code>## [1] 0.7562872</code></pre>
<p>This classifier, using <span class="math inline">\(0.1\)</span> instead of <span class="math inline">\(0.5\)</span> has a higher sensitivity, but a much lower specificity. Clearly, we should have moved the cutoff in the other direction. Let’s try <span class="math inline">\(0.9\)</span>.</p>
<pre class="sourceCode r"><code class="sourceCode r">spam_tst_pred_<span class="dv">90</span> =<span class="st"> </span><span class="kw">ifelse</span>(<span class="kw">predict</span>(fit_additive, spam_tst, <span class="dt">type =</span> <span class="st">&quot;response&quot;</span>) <span class="op">&gt;</span><span class="st"> </span><span class="fl">0.9</span>, 
                          <span class="st">&quot;spam&quot;</span>, 
                          <span class="st">&quot;nonspam&quot;</span>)</code></pre>
<p>This is essentially <em>increasing</em> the threshold for an email to be labeled as spam, so far <em>fewer</em> emails will be labeled as spam. Again, we see that in the following confusion matrix.</p>
<pre class="sourceCode r"><code class="sourceCode r">(<span class="dt">conf_mat_90 =</span> <span class="kw">make_conf_mat</span>(<span class="dt">predicted =</span> spam_tst_pred_<span class="dv">90</span>, <span class="dt">actual =</span> spam_tst<span class="op">$</span>type))</code></pre>
<pre><code>##          actual
## predicted nonspam spam
##   nonspam    2120  447
##   spam         67  967</code></pre>
<p>This is the result we’re looking for. We have far fewer false positives. While sensitivity is greatly reduced, specificity has gone up.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">get_sens</span>(conf_mat_<span class="dv">90</span>)</code></pre>
<pre><code>## [1] 0.6838755</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">get_spec</span>(conf_mat_<span class="dv">90</span>)</code></pre>
<pre><code>## [1] 0.9693644</code></pre>
<p>While this is far fewer false positives, is it acceptable though? Still probably not. Also, don’t forget, this would actually be a terrible spam detector today since this is based on data from a very different era of the internet, for a very specific set of people. Spam has changed a lot since 90s! (Ironically, machine learning is probably partially to blame.)</p>
<p>This chapter has provided a rather quick introduction to classification, and thus, machine learning. For a more complete coverage of machine learning, <a href="http://www-bcf.usc.edu/~gareth/ISL/" target="_blank">An Introduction to Statistical Learning</a> is a highly recommended resource. Additionally, <a href="https://daviddalpiaz.github.io/r4sl/" target="_blank"><code>R</code> for Statistical Learning</a> has been written as a supplement which provides additional detail on how to perform these methods using <code>R</code>. The <a href="https://daviddalpiaz.github.io/r4sl/classification-overview.html" target="_blank">classification</a> and <a href="https://daviddalpiaz.github.io/r4sl/logistic-regression.html" target="_blank">logistic regression</a> chapters might be useful.</p>
<p>We should note that the code to perform classification using logistic regression is presented in a way that illustrates the concepts to the reader. In practice, you may to prefer to use a more general machine learning pipeline such as <a href="http://topepo.github.io/caret/index.html" target="_blank"><code>caret</code></a> in <code>R</code>. This will streamline processes for creating predictions and generating evaluation metrics.</p>
</div>
</div>
<div id="r-markdown-10" class="section level2">
<h2><span class="header-section-number">17.5</span> <code>R</code> Markdown</h2>
<p>The <code>R</code> Markdown file for this chapter can be found here:</p>
<ul>
<li><a href="logistic.Rmd" target="_blank"><code>logistic.Rmd</code></a></li>
</ul>
<p>The file was created using <code>R</code> version <code>3.5.0</code>.</p>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="variable-selection-and-model-building.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="beyond.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/daviddalpiaz/appliedstats/edit/master/logistic.Rmd",
"text": "Edit"
},
"download": ["applied_statistics.pdf"],
"toc": {
"collapse": "section"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
